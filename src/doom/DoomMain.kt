package doom

import automap.IAutoMap
import com.hiperbou.lang.apply
import com.hiperbou.lang.times
import com.hiperbou.lang.transform
import com.hiperbou.lang.transformIndexed
import data.*
import data.Limits.MAXEVENTS
import data.sounds.musicenum_t
import data.sounds.sfxenum_t
import defines.*
import defines.GameMission_t.pack_plut
import defines.GameMission_t.pack_tnt
import defines.gamestate_t.*
import demo.IDemoTicCmd
import demo.VanillaDoomDemo
import demo.VanillaTiccmd
import doom.CommandVariable.*
import doom.SourceCode.*
import doom.event_t.mouseevent_t
import f.EndLevel
import f.Finale
import f.Wiper
import f.Wiper.Wipe
import g.Signals.ScanCode
import hu.HU
import i.*
import m.*
import m.fixed_t.Companion.FRACBITS
import m.fixed_t.Companion.MAPFRACUNIT
import mochadoom.Engine
import n.DoomSystemNetworking
import n.DummyNetworkDriver
import p.AbstractLevelLoader
import p.ActionFunctions
import p.BoomLevelLoader
import rr.*
import s.IDoomSound
import s.IMusic
import s.ISoundDriver
import savegame.IDoomSaveGame
import savegame.IDoomSaveGameHeader
import savegame.VanillaDSG
import savegame.VanillaDSGHeader
import st.AbstractStatusBar
import st.StatusBar
import timing.ITicker
import timing.MilliTicker
import utils.C2JUtils
import v.DoomGraphicSystem
import v.renderers.BppMode
import v.renderers.DoomScreen
import v.renderers.RendererFactory
import v.scale.VideoScale
import v.scale.VisualSettings
import w.IWadLoader
import w.IWritableDoomObject
import w.WadLoader
import java.awt.Rectangle
import java.io.*
import java.util.*
import java.util.function.Consumer


//-----------------------------------------------------------------------------
//
// $Id: DoomMain.java,v 1.109 2012/11/06 16:04:58 velktron Exp $
//
// Copyright (C) 1993-1996 by id Software, Inc.
// Copyright (C) 2022 hiperbou
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//  In Mocha Doom, this was unified with d_game and doomstat.c
//
//-----------------------------------------------------------------------------
class DoomMain<T, V> : DoomStatus<T, V>(), IDoomGameNetworking, IDoomGame, IDoom {
    //
    // EVENT HANDLING
    //
    // Events are asynchronous inputs generally generated by the game user.
    // Events can be discarded if no responder claims them
    //
    val events = arrayOfNulls<event_t>(Limits.MAXEVENTS)
    var eventhead = 0
    var eventtail = 0

    /**
     * D_PostEvent
     * Called by the I/O functions when input is detected
     */
    override fun PostEvent(ev: event_t) {
        /**
         * Do not pollute DOOM's internal event queue - clear keys there
         * - Good Sign 2017/04/24
         */
        if (ev === event_t.CANCEL_KEYS) {
            // PAINFULLY and FORCEFULLY clear the buttons.
            C2JUtils.memset(gamekeydown, false, gamekeydown.size)
            keysCleared = true
            return  // Nothing more to do here.
        }
        events[eventhead] = ev
        eventhead = ++eventhead and Limits.MAXEVENTS - 1
    }

    /**
     * D_ProcessEvents
     * Send all the events of the given timestamp down the responder chain
     */
    @D_Main.C(D_Main.D_ProcessEvents)
    fun ProcessEvents() {
        // IF STORE DEMO, DO NOT ACCEPT INPUT
        if (isCommercial()) {
            W_CheckNumForName@ run {
                if (wadLoader.CheckNumForName("MAP01") < 0) {
                    return
                }
            }
        }
        while (eventtail != eventhead) {
            val ev = events[eventtail]!!
            ev.withMouse { it.processedNotify() }
            //M_Responder@ run {
                if (menu.Responder(ev)) {
                    eventtail = ++eventtail and MAXEVENTS - 1
                    continue  // menu ate the event
                }
            //}
            G_Responder@ run {
                Responder(ev)
            }
            eventtail = ++eventtail and MAXEVENTS - 1
        }
    }

    // "static" to Display, don't move.
    private var viewactivestate = false
    private var menuactivestate = false
    private var inhelpscreensstate = false
    private var fullscreen = false
    private var oldgamestate = GS_MINUS_ONE
    private var borderdrawcount = 0

    /**
     * D_Display
     * draw current display, possibly wiping it from the previous
     * @throws IOException
     */
    @Throws(IOException::class)
    fun Display() {
        var nowtime: Int
        var tics: Int
        var wipestart: Int
        val y: Int
        var done: Boolean
        val wipe: Boolean
        var redrawsbar: Boolean

        // for comparative timing / profiling
        if (nodrawers) {
            return
        }
        redrawsbar = false

        // change the view size if needed
        if (sceneRenderer.getSetSizeNeeded()) {
            sceneRenderer.ExecuteSetViewSize()
            // force background redraw
            oldgamestate = GS_MINUS_ONE
            borderdrawcount = 3
        }

        // save the current screen if about to wipe
        wipe = gamestate != wipegamestate
        if (wipe) {
            wiper.StartScreen(0, 0, vs.getScreenWidth(), vs.getScreenHeight())
        }
        if (gamestate == GS_LEVEL && C2JUtils.eval(gametic)) {
            headsUp.Erase()
        }
        when (gamestate) {
            GS_LEVEL -> {
                if (C2JUtils.eval(gametic)) {
                    if (automapactive) {
                        autoMap.Drawer()
                    }
                    if (wipe || !sceneRenderer.isFullHeight() && fullscreen || inhelpscreensstate && !inhelpscreens
                        || diskDrawer.justDoneReading()
                    ) {
                        redrawsbar = true // just put away the help screen
                    }
                    statusBar.Drawer(sceneRenderer.isFullHeight(), redrawsbar)
                    fullscreen = sceneRenderer.isFullHeight()   
                }
            }
            GS_INTERMISSION -> endLevel.Drawer()
            GS_FINALE -> finale.Drawer()
            GS_DEMOSCREEN -> PageDrawer()
            else -> {}
        }

        // draw the view directly
        if (gamestate == GS_LEVEL && !automapactive && C2JUtils.eval(gametic)) {
            if (flashing_hom) {
                graphicSystem.FillRect(
                    DoomScreen.FG, Rectangle(
                        view!!.getViewWindowX(), view!!.getViewWindowY(),
                        view!!.getScaledViewWidth(), view!!.getScaledViewHeight()
                    ), gametic % 256
                )
            }
            sceneRenderer.RenderPlayerView(players[displayplayer])
        }

        // Automap was active, update only HU.
        if (gamestate == GS_LEVEL && C2JUtils.eval(gametic)) {
            headsUp.Drawer()
        }

        // clean up border stuff
        if (gamestate != oldgamestate && gamestate != GS_LEVEL) {
            graphicSystem.setPalette(0)
        }

        // see if the border needs to be initially drawn
        if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL) {
            // view was not active
            viewactivestate = false
            // draw the pattern into the back screen
            sceneRenderer.FillBackScreen()
        }

        // see if the border needs to be updated to the screen
        if (gamestate == GS_LEVEL && !automapactive && !sceneRenderer.isFullScreen()) {
            if (menuactive || menuactivestate || !viewactivestate) {
                borderdrawcount = 3
            }
            if (C2JUtils.eval(borderdrawcount)) {
                // erase old menu stuff
                sceneRenderer.DrawViewBorder()
                borderdrawcount--
            }
        }
        menuactivestate = menuactive
        viewactivestate = viewactive
        inhelpscreensstate = inhelpscreens
        wipegamestate = gamestate
        oldgamestate = wipegamestate

        // draw pause pic
        if (_paused) {
            y = if (automapactive) {
                4 * graphicSystem.getScalingY()
            } else {
                view!!.getViewWindowY() + 4 * graphicSystem.getScalingY()
            }
            val pause = wadLoader.CachePatchName("M_PAUSE", Defines.PU_CACHE)
            graphicSystem.DrawPatchCenteredScaled(
                DoomScreen.FG,
                pause,
                vs,
                y,
                DoomGraphicSystem.V_NOSCALESTART
            )
        }

        // menus go directly to the screen
        menu.Drawer() // menu is drawn even on top of everything
        NetUpdate() // send out any new accumulation

        // Disk access goes after everything.
        diskDrawer.Drawer()

        // normal update
        if (!wipe) {
            //System.out.print("Tick "+gametic+"\t");
            //System.out.print(players[0]);
            Engine.updateFrame() // page flip or blit buffer
            return
        }

        // wipe update. At this point, AT LEAST one frame of the game must have been
        // rendered for this to work. 22/5/2011: Fixed a vexing bug with the wiper.
        // Jesus Christ with a Super Shotgun!
        wiper.EndScreen(0, 0, vs.getScreenWidth(), vs.getScreenHeight())
        wipestart = ticker.GetTime() - 1
        do {
            do {
                nowtime = ticker.GetTime()
                tics = nowtime - wipestart
            } while (tics == 0) // Wait until a single tic has passed.
            wipestart = nowtime
            val wipeType = if (CM.equals(Settings.scale_melt, java.lang.Boolean.TRUE)) Wipe.ScaledMelt else Wipe.Melt
            done = wiper.ScreenWipe(wipeType, 0, 0, vs.getScreenWidth(), vs.getScreenHeight(), tics)
            soundDriver.UpdateSound()
            soundDriver.SubmitSound() // update sounds after one wipe tic.
            menu.Drawer() // menu is drawn even on top of wipes
            Engine.updateFrame() // page flip or blit buffer
        } while (!done)
    }

    /**
     * To be able to debug vanilla incompatibilitites, the DoomLoop
     * and all that is called by it that relates to the Loop itself,
     * the ticks, game object modifications, mode changes and so on,
     * ***MUST*** be preceded by a label, containing original
     * underscored naming of the method in Doom Source Code.
     *
     * Remember the label blocks will retain their name even in case
     * of *automated refactoring*, thus if you rename some method
     * and update it throughout the whole codebase, the named label
     * will still be named the same underscored original method name
     *
     * Do it the most verbose way you can - preserving both, or all
     * brackets of all blocks containing and contained in the label,
     * and the brackets of the label itself, with one exception:
     *
     * If there is no more function to do the task was given to the
     * function in original Doom Source Code, the label stull ***MUST***
     * be present, just type a semicolon to end it without actions.
     * The syntax is short and displays clearly that nothing is done.
     * - Good Sign 2017/04/26
     *
     * D_DoomLoop()
     * Not a globally visible function,
     * just included for source reference,
     * called by D_DoomMain, never exits.
     * Manages timing and IO,
     * calls all ?_Responder, ?_Ticker, and ?_Drawer,
     * calls I_GetTime, I_StartFrame, and I_StartTic
     * @throws IOException
     */
    @D_Main.C(D_Main.D_DoomLoop)
    @Throws(IOException::class)
    fun DoomLoop() {
        if (demorecording) {
            G_BeginRecording@ run {
                BeginRecording()
            }
        }
        M_CheckParm@ run {
            if (cVarManager.bool(CommandVariable.DEBUGFILE)) {
                val filename = "debug$consoleplayer.txt"
                println("debug output to: $filename")
                try {
                    debugfile = OutputStreamWriter(FileOutputStream(filename))
                } catch (e: FileNotFoundException) {
                    System.err.println("Couldn't open debugfile. Now, that sucks some putrid shit out of John Romero's asshole!")
                    e.printStackTrace()
                }
            }
        }
        I_InitGraphics@ run {
            view = sceneRenderer.getView()
        }
        while (true) {
            // frame syncronous IO operations
            I_StartFrame@

            // process one or more tics
            if (singletics) {
                I_StartTic@
                D_ProcessEvents@ run {
                    ProcessEvents()
                }
                G_BuildTiccmd@ run {
                    BuildTiccmd(netcmds[consoleplayer][maketic % Defines.BACKUPTICS]!!)
                }
                if (advancedemo) {
                    D_DoAdvanceDemo@ run {
                        DoAdvanceDemo()
                    }
                }
                M_Ticker@ run {
                    menu.Ticker()
                }
                G_Ticker@ run {
                    Ticker()
                }
                gametic++
                maketic++
            } else {
                gameNetworking.TryRunTics() // will run at least one tic (in NET)
            }
            S_UpdateSounds@ run {
                doomSound.UpdateSounds(players[consoleplayer].mo!!) // move positional sounds
            }
            D_Display@ run { // Update display, next frame, with current state.
                Display()
            }
            //#ifndef SNDSERV
            // Sound mixing for the buffer is snychronous.
            soundDriver.UpdateSound()
            //#endif
            // Synchronous sound output is explicitly called.
            //#ifndef SNDINTR
            // Update sound output.
            soundDriver.SubmitSound()
            //#endif
        }
    }

    // To keep an "eye" on the renderer.
    protected var view: ViewVars? = null

    //
    //  DEMO LOOP
    //
    var demosequence = 0
    var pagetic = 0
    var pagename: String? = null

    /**
     * D_PageTicker
     * Handles timing for warped projection
     */
    override fun PageTicker() {
        if (--pagetic < 0) {
            AdvanceDemo()
        }
    }

    /**
     * D_PageDrawer
     */
    override fun PageDrawer() {
        // FIXME: this check wasn't necessary in vanilla, since pagename was
        // guaranteed(?) not to be null or had a safe default value.
        if (pagename != null) {
            graphicSystem.DrawPatchScaled(
                DoomScreen.FG,
                wadLoader.CachePatchName(pagename!!, Defines.PU_CACHE),
                vs,
                0,
                0,
                DoomGraphicSystem.V_SAFESCALE
            )
        }
    }

    /**
     * D_AdvanceDemo
     * Called after each demo or intro demosequence finishes
     */
    override fun AdvanceDemo() {
        advancedemo = true
    }

    /**
     * This cycles through the demo sequences.
     * FIXME - version dependant demo numbers?
     */
    fun DoAdvanceDemo() {
        players[consoleplayer].playerstate = Defines.PST_LIVE // not reborn
        advancedemo = false
        usergame = false // no save / end game here
        _paused = false
        gameaction = gameaction_t.ga_nothing
        demosequence = if (isRetail()) // Allows access to a 4th demo.
        {
            (demosequence + 1) % 7
        } else {
            (demosequence + 1) % 6
        }
        when (demosequence) {
            0 -> {
                pagetic = if (isCommercial()) {
                    35 * 11
                } else {
                    170
                }
                gamestate = GS_DEMOSCREEN
                if (wadLoader.CheckNumForName("TITLEPIC") != -1) {
                    pagename = "TITLEPIC"
                } else {
                    if (wadLoader.CheckNumForName("DMENUPIC") != -1) {
                        pagename = "DMENUPIC"
                    }
                }
                if (isCommercial()) {
                    doomSound.StartMusic(musicenum_t.mus_dm2ttl)
                } else {
                    doomSound.StartMusic(musicenum_t.mus_intro)
                }
            }
            1 -> DeferedPlayDemo("demo1")
            2 -> {
                pagetic = 200
                gamestate = GS_DEMOSCREEN
                pagename = "CREDIT"
            }
            3 -> DeferedPlayDemo("demo2")
            4 -> {
                gamestate = GS_DEMOSCREEN
                if (isCommercial()) {
                    pagetic = 35 * 11
                    pagename = "TITLEPIC"
                    doomSound.StartMusic(musicenum_t.mus_dm2ttl)
                } else {
                    pagetic = 200
                    pagename = if (isRetail()) {
                        "CREDIT"
                    } else {
                        "HELP1"
                    }
                }
            }
            5 -> DeferedPlayDemo("demo3")
            6 -> DeferedPlayDemo("demo4")
        }
    }

    /**
     * D_StartTitle
     */
    override fun StartTitle() {
        gameaction = gameaction_t.ga_nothing
        demosequence = -1
        AdvanceDemo()
    }

    // print title for every printed line
    var title = StringBuffer()

    /**
     * D_AddFile
     *
     * Adds file to the end of the wadfiles[] list.
     * Quite crude, we could use a listarray instead.
     *
     * @param file
     */
    private fun AddFile(file: String) {
        var numwadfiles: Int
        numwadfiles = 0
        while (C2JUtils.eval(wadfiles[numwadfiles])) {
            numwadfiles++
        }
        wadfiles[numwadfiles] = file
    }

    /**
     * IdentifyVersion
     * Checks availability of IWAD files by name,
     * to determine whether registered/commercial features
     * should be executed (notably loading PWAD's).
     */
    fun IdentifyVersion(): String? {
        var doomwaddir: String?
        // By default.
        language = Language_t.english

        // First, check for -iwad parameter.
        // If valid, then it trumps all others.
        if (cVarManager.present(CommandVariable.IWAD)) {
            println("-iwad specified. Will be used with priority\n")
            // It might be quoted.
            val test = C2JUtils.unquoteIfQuoted(cVarManager.get(CommandVariable.IWAD, String::class.java, 0).get(), '"')
            val separator = System.getProperty("file.separator")
            val iwad = test.substring(1 + test.lastIndexOf(separator))
            doomwaddir = test.substring(0, 1 + test.lastIndexOf(separator))
            val attempt = DoomVersion.tryOnlyOne(iwad, doomwaddir)
            // Note: at this point we can't distinguish between "doom" retail
            // and "doom" ultimate yet.
            if (attempt != null) {
                AddFile(doomwaddir + iwad)
                this.setGameMode(attempt)
                return doomwaddir + iwad
            }
        } else {
            // Unix-like checking. Might come in handy sometimes.
            // This should ALWAYS be activated, else doomwaddir etc. won't be defined.
            doomwaddir = System.getenv("DOOMWADDIR")
            if (doomwaddir != null) {
                println("DOOMWADDIR found. Will be used with priority\n")
            }

            // None found, using current.
            if (!C2JUtils.eval(doomwaddir)) {
                doomwaddir = "."
            }
        }
        for (mode in GameMode.values()) {
            if (mode != GameMode.indetermined && cVarManager.bool(mode.devVar)) {
                return devParmOn(mode)
            }
        }
        val wadFullPath = DoomVersion.tryAllWads(this, doomwaddir!!)
        if (wadFullPath == null) {
            println("Game mode indeterminate.\n")
            setGameMode(GameMode.indetermined)
            // We don't abort. Let's see what the PWAD contains.
            //exit(1);
            //I_Error ("Game mode indeterminate\n");
        } else {
            AddFile(wadFullPath)
        }
        return wadFullPath
    }

    private fun devParmOn(mode: GameMode): String {
        setGameMode(mode)
        devparm = true
        AddFile(dstrings.DEVDATA + mode.version)
        AddFile(dstrings.DEVMAPS + mode.devDir + "/texture1.lmp")
        if (mode.hasTexture2()) {
            AddFile(dstrings.DEVMAPS + mode.devDir + "/texture2.lmp")
        }
        AddFile(dstrings.DEVMAPS + mode.devDir + "/pnames.lmp")
        return dstrings.DEVDATA + mode.version
    }

    /**
     *
     */
    protected fun CheckForPWADSInShareware() {
        if (modifiedgame) {
            // These are the lumps that will be checked in IWAD,
            // if any one is not present, execution will be aborted.
            val name = arrayOf(
                "e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8", "e2m9",
                "e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8", "e3m9",
                "dphoof", "bfgga0", "heada1", "cybra1", "spida1d1"
            )
            var i: Int

            // Oh yes I can.
            if (isShareware()) {
                println("\nYou cannot -file with the shareware version. Register!")
            }

            // Check for fake IWAD with right name,
            // but w/o all the lumps of the registered version.
            if (isRegistered()) {

                name.forEach {
                    if (wadLoader.CheckNumForName(it.uppercase(Locale.getDefault())) < 0) {
                        doomSystem.Error(
                            """
    
    This is not the registered version: $it
    """.trimIndent()
                        )
                    }

                }
            }
        }
    }

    /** Check whether the "doom.wad" we actually loaded
     * is ultimate Doom's, by checking if it contains
     * e4m1 - e4m9.
     *
     */
    protected fun CheckForUltimateDoom(W: WadLoader) {
        if (isRegistered()) {
            // These are the lumps that will be checked in IWAD,
            // if any one is not present, execution will be aborted.
            val lumps = arrayOf("e4m1", "e4m2", "e4m3", "e4m4", "e4m5", "e4m6", "e4m7", "e4m8", "e4m9")

            // Check for fake IWAD with right name,
            // but w/o all the lumps of the registered version.
            if (!CheckForLumps(lumps, W)) return
            // Checks passed, so we can set the mode to Ultimate
            setGameMode(GameMode.retail)
        }
    }

    /** Check if ALL of the lumps exist.
     *
     * @param name
     * @return
     */
    protected fun CheckForLumps(name: Array<String>, W: WadLoader): Boolean {
        for (name1 in name) {
            if (W.CheckNumForName(name1.uppercase(Locale.getDefault())) < 0) {
                // Even one is missing? Not OK.
                return false
            }
        }
        return true
    }

    /**
     *
     */
    protected fun GenerateTitle() {
        when (getGameMode()) {
            GameMode.retail -> {
                title.append("                         ")
                title.append("The Ultimate DOOM Startup v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.shareware -> {
                title.append("                            ")
                title.append("DOOM Shareware Startup v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.registered -> {
                title.append("                            ")
                title.append("DOOM Registered Startup v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.commercial -> {
                title.append("                            ")
                title.append("DOOM 2: Hell on Earth v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.pack_plut -> {
                title.append("                            ")
                title.append("DOOM 2: Plutonia Experiment v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.pack_tnt -> {
                title.append("                            ")
                title.append("DOOM 2: TNT - Evilution v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.pack_xbla -> {
                title.append("                            ")
                title.append("DOOM 2: No Rest for the Living v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.freedm -> {
                title.append("                            ")
                title.append("FreeDM                     v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.freedoom1 -> {
                title.append("                            ")
                title.append("FreeDoom: Phase 1          v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            GameMode.freedoom2 -> {
                title.append("                            ")
                title.append("FreeDoom: Phase 2          v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
            else -> {
                title.append("                            ")
                title.append("Public DOOM - v")
                title.append(Defines.VERSION / 100)
                title.append(".")
                title.append(Defines.VERSION % 100)
                title.append("                           ")
            }
        }
    }

    // Used in BuildTiccmd.
    protected var base = ticcmd_t()

    /**
     * G_BuildTiccmd
     * Builds a ticcmd from all of the available inputs
     * or reads it from the demo buffer.
     * If recording a demo, write it out .
     *
     * The CURRENT event to process is written to the various
     * gamekeydown etc. arrays by the Responder method.
     * So look there for any fuckups in constructing them.
     *
     */
    @Compatible
    @G_Game.C(G_Game.G_BuildTiccmd)
    private fun BuildTiccmd(cmd: ticcmd_t) {
        var i: Int
        val strafe: Boolean
        val bstrafe: Boolean
        val speed: Int
        val tspeed: Int
        val lspeed: Int
        var forward: Int
        var side: Int
        var look: Int
        I_BaseTiccmd@ // empty, or external driver
        base.copyTo(cmd)
        cmd.consistancy = consistancy[consoleplayer][maketic % Defines.BACKUPTICS]
        strafe = gamekeydown[key_strafe] || mousebuttons(mousebstrafe) || joybuttons(joybstrafe)
        speed = if (gamekeydown[key_speed] xor alwaysrun || joybuttons(joybspeed)) 1 else 0
        look = 0
        side = look
        forward = side

        // use two stage accelerative turning
        // on the keyboard and joystick
        if (joyxmove < 0 || joyxmove > 0 || gamekeydown[key_right] || gamekeydown[key_left]) {
            turnheld += _ticdup
        } else {
            turnheld = 0
        }
        tspeed = if (turnheld < DoomStatus.SLOWTURNTICS) 2 /* slowturn */ else speed
        if (gamekeydown[key_lookdown] || gamekeydown[key_lookup]) {
            lookheld += _ticdup
        } else {
            lookheld = 0
        }
        lspeed = if (lookheld < DoomStatus.SLOWTURNTICS) 1 else 2

        // let movement keys cancel each other out
        if (strafe) {
            if (gamekeydown[key_right]) {
                // fprintf(stderr, "strafe right\n");
                side += sidemove[speed]
            }
            if (gamekeydown[key_left]) {
                //  fprintf(stderr, "strafe left\n");
                side -= sidemove[speed]
            }
            if (joyxmove > 0) {
                side += sidemove[speed]
            } else if (joyxmove < 0) {
                side -= sidemove[speed]
            }
        } else {
            
            if (gamekeydown[key_right]) {
                cmd.angleturn = (cmd.angleturn - angleturn[tspeed]).toShort()
            }

            if (gamekeydown[key_left]) {
                cmd.angleturn = (cmd.angleturn + angleturn[tspeed]).toShort()
            }

            if (joyxmove > 0) {
                cmd.angleturn = (cmd.angleturn - angleturn[tspeed]).toShort()
            } else if (joyxmove < 0) {
                cmd.angleturn = (cmd.angleturn + angleturn[tspeed]).toShort()
            }
        }
        if (gamekeydown[key_up]) {
            //System.err.print("up\n");
            forward += forwardmove[speed]
        }
        if (gamekeydown[key_down]) {
            //System.err.print("down\n");
            forward -= forwardmove[speed]
        }
        if (joyymove < 0) {
            forward += forwardmove[speed]
        } else if (joyymove > 0) {
            forward -= forwardmove[speed]
        }
        if (gamekeydown[key_straferight]) {
            side += sidemove[speed]
        }
        if (gamekeydown[key_strafeleft]) {
            side -= sidemove[speed]
        }

        // Look up/down/center keys
        if (gamekeydown[key_lookup]) {
            //System.err.print("Look up\n")
            look = lspeed
        }
        if (gamekeydown[key_lookdown]) {
            //System.err.print("Look down\n")
            look = -lspeed
        }
        if (gamekeydown[key_lookcenter]) {
            //System.err.print("Center look\n")
            look = Defines.TOCENTER
        }

        // buttons
        cmd.chatchar = headsUp.dequeueChatChar()
        if (gamekeydown[key_fire] || mousebuttons(mousebfire) || joybuttons(joybfire)) {
            cmd.buttons = (cmd.buttons.code or Defines.BT_ATTACK).toChar()
        }
        if (gamekeydown[key_use] || joybuttons(joybuse)) {
            cmd.buttons = (cmd.buttons.code or Defines.BT_USE).toChar()
            // clear double clicks if hit use button
            dclicks = 0
        }

        // chainsaw overrides
        i = 0
        while (i < Defines.NUMWEAPONS - 1) {
            if (gamekeydown[key_numbers[i]]) {
                //System.out.println("Attempting weapon change (building ticcmd)");
                cmd.buttons = (cmd.buttons.code or Defines.BT_CHANGE).toChar()
                cmd.buttons = (cmd.buttons.code or (i shl Defines.BT_WEAPONSHIFT)).toChar()
                break
            }
            i++
        }

        // mouse
        if (mousebuttons(mousebforward)) {
            forward += forwardmove[speed]
        }

        // forward double click
        if (mousebuttons(mousebforward) != C2JUtils.eval(dclickstate) && dclicktime > 1) {
            dclickstate = if (mousebuttons(mousebforward)) 1 else 0
            if (dclickstate != 0) {
                dclicks++
            }
            if (dclicks == 2) {
                cmd.buttons = (cmd.buttons.code or Defines.BT_USE).toChar()
                dclicks = 0
            } else {
                dclicktime = 0
            }
        } else {
            dclicktime += _ticdup
            if (dclicktime > 20) {
                dclicks = 0
                dclickstate = 0
            }
        }

        // strafe double click
        bstrafe = mousebuttons(mousebstrafe) || joybuttons(joybstrafe)
        if (bstrafe != C2JUtils.eval(dclickstate2) && dclicktime2 > 1) {
            dclickstate2 = if (bstrafe) 1 else 0
            if (dclickstate2 != 0) {
                dclicks2++
            }
            if (dclicks2 == 2) {
                cmd.buttons = (cmd.buttons.code or Defines.BT_USE).toChar()
                dclicks2 = 0
            } else {
                dclicktime2 = 0
            }
        } else {
            dclicktime2 += _ticdup
            if (dclicktime2 > 20) {
                dclicks2 = 0
                dclickstate2 = 0
            }
        }

        // By default, no vertical mouse movement
        if (!novert) {
            forward += mousey
        }
        if (strafe) {
            side += mousex * 2
        } else {
            cmd.angleturn = (cmd.angleturn - (mousex * 0x8)).toShort()
        }
        mousey = 0
        mousex = mousey
        if (forward > MAXPLMOVE()) {
            forward = MAXPLMOVE()
        } else if (forward < -MAXPLMOVE()) {
            forward = -MAXPLMOVE()
        }
        if (side > MAXPLMOVE()) {
            side = MAXPLMOVE()
        } else if (side < -MAXPLMOVE()) {
            side = -MAXPLMOVE()
        }
        cmd.forwardmove = (cmd.forwardmove +  forward).toByte()
        cmd.sidemove = (cmd.sidemove + side).toByte()
        if (players[consoleplayer].playerstate == Defines.PST_LIVE) {
            if (look < 0) {
                look += 16
            }
            cmd.lookfly = look.toChar()
        }

        // special buttons
        if (sendpause) {
            sendpause = false
            cmd.buttons = (Defines.BT_SPECIAL or Defines.BTS_PAUSE).toChar()
        }
        if (sendsave) {
            sendsave = false
            cmd.buttons =
                (Defines.BT_SPECIAL or Defines.BTS_SAVEGAME or (savegameslot shl Defines.BTS_SAVESHIFT)).toChar()
        }
    }

    /**
     * G_DoLoadLevel
     *
     * //extern gamestate_t wipegamestate;
     */
    @Suspicious(CauseOfDesyncProbability.LOW)
    @G_Game.C(G_Game.G_DoLoadLevel)
    fun DoLoadLevel(): Boolean {
        /**
         * Added a config switch to this fix
         * - Good Sign 2017/04/26
         *
         * Fixed R_FlatNumForName was a part of the fix, not vanilla code
         * - Good Sign 2017/05/07
         *
         * DOOM determines the sky texture to be used
         * depending on the current episode, and the game version.
         *
         * @SourceCode.Compatible
         */
        if (Engine.getConfig().equals(
                Settings.fix_sky_change,
                java.lang.Boolean.TRUE
            ) && (isCommercial() || gamemission == pack_tnt || gamemission == pack_plut)
        ) {
            // Set the sky map.
            // First thing, we have a dummy sky texture name,
            //  a flat. The data is in the WAD only because
            //  we look for an actual index, instead of simply
            //  setting one.
            textureManager.setSkyFlatNum(textureManager.FlatNumForName(Defines.SKYFLATNAME))
            textureManager.setSkyTexture(textureManager.TextureNumForName("SKY3"))
            if (gamemap < 12) {
                textureManager.setSkyTexture(textureManager.TextureNumForName("SKY1"))
            } else {
                if (gamemap < 21) {
                    textureManager.setSkyTexture(textureManager.TextureNumForName("SKY2"))
                }
            }
        }
        levelstarttic = gametic // for time calculation
        if (wipegamestate == GS_LEVEL) wipegamestate = GS_MINUS_ONE // force a wipe
        gamestate = GS_LEVEL
        for (i in 0 until Limits.MAXPLAYERS) {
            if (playeringame[i] && players[i].playerstate == Defines.PST_DEAD) {
                players[i].playerstate = Defines.PST_REBORN
            }
            C2JUtils.memset(players[i].frags, 0, players[i].frags.size)
        }
        try {
            P_SetupLevel@ run {
                levelLoader.SetupLevel(gameepisode, gamemap, 0, gameskill)
            }
        } catch (e: IOException) {
            e.printStackTrace()
            // Failure loading level.
            return false
        }
        displayplayer = consoleplayer // view the guy you are playing
        I_GetTime@ run {
            starttime = ticker.GetTime()
        }
        gameaction = gameaction_t.ga_nothing
        Z_CheckHeap@

        // clear cmd building stuff
        C2JUtils.memset(gamekeydown, false, gamekeydown.size)
        keysCleared = true
        joyymove = 0
        joyxmove = joyymove
        mousey = 0
        mousex = mousey
        _paused = false
        sendsave = _paused
        sendpause = sendsave
        C2JUtils.memset(mousearray, false, mousearray.size)
        C2JUtils.memset(joyarray, false, joyarray.size)
        /**
         * Probably no desync-effect
         * - GoodSign 2017/05/07
         *
         * @SourceCode.Suspicious
         */

        // killough 5/13/98: in case netdemo has consoleplayer other than green
        statusBar.Start()
        headsUp.Start()

        // killough: make -timedemo work on multilevel demos
        // Move to end of function to minimize noise -- killough 2/22/98:
        if (timingdemo) {
            if (first) {
                starttime = RealTime.GetTime()
                first = false
            }
        }

        // Try reclaiming some memory from limit-expanded buffers.
        sceneRenderer.resetLimits()
        return true
    }

    protected var first = true

    /**
     * G_Responder
     * Get info needed to make ticcmd_ts for the players.
     */
    @Compatible
    @G_Game.C(G_Game.G_Responder)
    fun Responder(ev: event_t): Boolean {
        // allow spy mode changes even during the demo
        if (gamestate == GS_LEVEL && ev.isKey(
                ScanCode.SC_F12,
                evtype_t.ev_keydown
            ) && (singledemo || !deathmatch)
        ) {
            // spy mode
            do {
                displayplayer++
                if (displayplayer == Limits.MAXPLAYERS) {
                    displayplayer = 0
                }
            } while (!playeringame[displayplayer] && displayplayer != consoleplayer)
            return true
        }

        // any other key pops up menu if in demos
        if (gameaction == gameaction_t.ga_nothing && !singledemo && (demoplayback || gamestate == GS_DEMOSCREEN)) {
            if (ev.isType(evtype_t.ev_keydown)
                || ev.ifMouse(evtype_t.ev_mouse) { obj -> obj.hasData() }
                || ev.ifJoy(evtype_t.ev_joystick) { obj -> obj.hasData() }
            ) {
                M_StartControlPanel@ run {
                    menu.StartControlPanel()
                }
                return true
            }
            return false
        }
        if (gamestate == GS_LEVEL) {
            if (devparm && ev.isKey(ScanCode.SC_SEMICOLON, evtype_t.ev_keydown)) {
                G_DeathMatchSpawnPlayer@ run {
                    DeathMatchSpawnPlayer(0)
                }
                return true
            }
            HU_Responder@ run {
                if (headsUp.Responder(ev)) {
                    return true // chat ate the event
                }
            }
            ST_Responder@ run {
                if (statusBar.Responder(ev)) {
                    return true // status window ate it
                }
            }
            AM_Responder@ run {
                if (autoMap.Responder(ev)) {
                    return true // automap ate it
                }
            }
        }
        if (gamestate == GS_FINALE) {
            F_Responder@ run {
                if (finale.Responder(ev)) {
                    return true // finale ate the event
                }
            }
        }
        when (ev.type()) {
            evtype_t.ev_keydown -> {
                if (ev.isKey(ScanCode.SC_PAUSE)) {
                    sendpause = true
                    return true
                }
                ev.withKey { sc ->
                    gamekeydown[sc.ordinal] = true
                    if (vanillaKeyBehavior) {
                        when (sc) {
                            ScanCode.SC_LSHIFT, ScanCode.SC_RSHIFT -> {
                                gamekeydown[ScanCode.SC_LSHIFT.ordinal] = true
                                gamekeydown[ScanCode.SC_RSHIFT.ordinal] = gamekeydown[ScanCode.SC_LSHIFT.ordinal]
                            }
                            ScanCode.SC_LCTRL, ScanCode.SC_RCTRL -> {
                                gamekeydown[ScanCode.SC_LCTRL.ordinal] = true
                                gamekeydown[ScanCode.SC_RCTRL.ordinal] = gamekeydown[ScanCode.SC_LCTRL.ordinal]
                            }
                            ScanCode.SC_LALT, ScanCode.SC_RALT -> {
                                gamekeydown[ScanCode.SC_LALT.ordinal] = true
                                gamekeydown[ScanCode.SC_RALT.ordinal] = gamekeydown[ScanCode.SC_LALT.ordinal]
                            }
                            else -> {}
                        }
                    }
                }
                return true // eat key down events
            }
            evtype_t.ev_keyup -> {
                /* CAPS lock will only go through as a keyup event */if (ev.isKey(ScanCode.SC_CAPSLK)) {
                    // Just toggle it. It's too hard to read the state.
                    alwaysrun = !alwaysrun
                    players[consoleplayer].message = String.format("Always run: %s", alwaysrun)
                }
                ev.withKey { sc: ScanCode ->
                    gamekeydown[sc.ordinal] = false
                    if (vanillaKeyBehavior) {
                        when (sc) {
                            ScanCode.SC_LSHIFT, ScanCode.SC_RSHIFT -> {
                                gamekeydown[ScanCode.SC_LSHIFT.ordinal] = false
                                gamekeydown[ScanCode.SC_RSHIFT.ordinal] = gamekeydown[ScanCode.SC_LSHIFT.ordinal]
                            }
                            ScanCode.SC_LCTRL, ScanCode.SC_RCTRL -> {
                                gamekeydown[ScanCode.SC_LCTRL.ordinal] = false
                                gamekeydown[ScanCode.SC_RCTRL.ordinal] = gamekeydown[ScanCode.SC_LCTRL.ordinal]
                            }
                            ScanCode.SC_LALT, ScanCode.SC_RALT -> {
                                gamekeydown[ScanCode.SC_LALT.ordinal] = false
                                gamekeydown[ScanCode.SC_RALT.ordinal] = gamekeydown[ScanCode.SC_LALT.ordinal]
                            }
                            else -> {}
                        }
                    }
                }
                return false // always let key up events filter down
            }
            evtype_t.ev_mouse -> {
                // Ignore them at the responder level
                if (use_mouse) {
                    mousebuttons(0, ev.isMouse(event_t.MOUSE_LEFT))
                    mousebuttons(1, ev.isMouse(event_t.MOUSE_RIGHT))
                    mousebuttons(2, ev.isMouse(event_t.MOUSE_MID))
                    ev.withMouse { mouseEvent: mouseevent_t ->
                        mousex = mouseEvent.x * (mouseSensitivity + 5) / 10
                        mousey = mouseEvent.y * (mouseSensitivity + 5) / 10
                    }
                }
                return true // eat events
            }
            evtype_t.ev_joystick -> {
                if (use_joystick) {
                    joybuttons(0, ev.isJoy(event_t.JOY_1))
                    joybuttons(1, ev.isJoy(event_t.JOY_2))
                    joybuttons(2, ev.isJoy(event_t.JOY_3))
                    joybuttons(3, ev.isJoy(event_t.JOY_4))
                    ev.withJoy { joyEvent ->
                        joyxmove = joyEvent.x
                        joyymove = joyEvent.y
                    }
                }
                return true // eat events
            }
            else -> {}
        }
        return false
    }

    private val turbomessage = "is turbo!"

    /**
     * G_Ticker
     *
     * Make ticcmd_ts for the players.
     */
    @G_Game.C(G_Game.G_Ticker)
    fun Ticker() {
        // do player reborns if needed
        for (i in 0 until Limits.MAXPLAYERS) {
            if (playeringame[i] && players[i].playerstate == Defines.PST_REBORN) {
                G_DoReborn@ run {
                    DoReborn(i)
                }
            }
        }

        // do things to change the game state
        while (gameaction != gameaction_t.ga_nothing) {
            when (gameaction) {
                gameaction_t.ga_loadlevel -> G_DoLoadLevel@ run {
                    DoLoadLevel()
                }
                gameaction_t.ga_newgame -> G_DoNewGame@ run {
                    DoNewGame()
                }
                gameaction_t.ga_loadgame -> G_DoLoadGame@ run {
                    DoLoadGame()
                }
                gameaction_t.ga_savegame -> G_DoSaveGame@ run {
                    DoSaveGame()
                }
                gameaction_t.ga_playdemo -> G_DoPlayDemo@ run {
                    DoPlayDemo()
                }
                gameaction_t.ga_completed -> G_DoCompleted@ run {
                    DoCompleted()
                }
                gameaction_t.ga_victory -> finale.StartFinale()
                gameaction_t.ga_worlddone -> DoWorldDone()
                gameaction_t.ga_screenshot -> {
                    ScreenShot()
                    gameaction = gameaction_t.ga_nothing
                }
                gameaction_t.ga_nothing -> {}
                else -> {}
            }
        }

        // get commands, check consistancy,
        // and build new consistancy check
        val buf = gametic / _ticdup % Defines.BACKUPTICS
        for (i in 0 until Limits.MAXPLAYERS) {
            if (playeringame[i]) {
                val cmd = players[i].cmd
                //System.out.println("Current command:"+cmd);

                //memcpy (cmd, &netcmds[i][buf], sizeof(ticcmd_t));
                netcmds[i][buf]!!.copyTo(cmd)

                // MAES: this is where actual demo commands are being issued or created!
                // Essentially, a demo is a sequence of stored ticcmd_t with a header.
                // Knowing that, it's possible to objectify it.
                if (demoplayback) {
                    ReadDemoTiccmd(cmd)
                }
                if (demorecording) {
                    WriteDemoTiccmd(cmd)
                }

                // check for turbo cheats
                if (cmd.forwardmove > DoomStatus.TURBOTHRESHOLD && gametic and 31 == 0 && gametic shr 5 and 3 == i) {
                    //extern char *player_names[4];
                    //sprintf (turbomessage, "%s is turbo!",player_names[i]);
                    players[consoleplayer].message = HU.player_names.get(i) + turbomessage
                }
                if (netgame && !netdemo && gametic % _ticdup == 0) {
                    if (gametic > Defines.BACKUPTICS && consistancy[i][buf] != cmd.consistancy) {
                        doomSystem.Error("consistency failure (%d should be %d)", cmd.consistancy, consistancy[i][buf])
                    }
                    if (players[i].mo != null) {
                        consistancy[i][buf] = players[i].mo!!._x.toShort()
                    } else {
                        consistancy[i][buf] = random.index.toShort()
                    }
                }
            }
        }

        // check for special buttons
        for (i in 0 until Limits.MAXPLAYERS) {
            if (playeringame[i]) {
                if (players[i].cmd.buttons.code and Defines.BT_SPECIAL != 0) {
                    when (players[i].cmd.buttons.code and Defines.BT_SPECIALMASK) {
                        Defines.BTS_PAUSE -> {
                            // MAES: fixed stupid ^pause bug.
                            _paused = !_paused
                            if (_paused) {
                                doomSound.PauseSound()
                            } else {
                                doomSound.ResumeSound()
                            }
                        }
                        Defines.BTS_SAVEGAME -> {
                            if (savedescription == null) {
                                savedescription = "NET GAME"
                            }
                            savegameslot =
                                players[i].cmd.buttons.code and Defines.BTS_SAVEMASK shr Defines.BTS_SAVESHIFT
                            gameaction = gameaction_t.ga_savegame
                        }
                    }
                }
            }
        }
        when (gamestate) {
            GS_LEVEL -> {
                actions.Ticker()
                statusBar.Ticker()
                autoMap.Ticker()
                headsUp.Ticker()
            }
            GS_INTERMISSION -> endLevel.Ticker()
            GS_FINALE -> finale.Ticker()
            GS_DEMOSCREEN -> PageTicker()
            else -> {}
        }
    }
    //
    // PLAYER STRUCTURE FUNCTIONS
    // also see P_SpawnPlayer in P_Things
    //
    /**
     * G_InitPlayer
     * Called at the start.
     * Called by the game initialization functions.
     *
     * MAES: looks like dead code. It's never called.
     *
     */
    protected fun InitPlayer(player: Int) {
        // set up the saved info
        // clear everything else to defaults
        players[player]!!.PlayerReborn()
    }

    //
    // G_CheckSpot
    // Returns false if the player cannot be respawned
    // at the given mapthing_t spot
    // because something is occupying it
    //
    //void P_SpawnPlayer (mapthing_t* mthing);
    @SourceCode.Exact
    @G_Game.C(G_Game.G_CheckSpot)
    private fun CheckSpot(playernum: Int, mthing: mapthing_t): Boolean {
        if (players[playernum].mo == null) {
            // first spawn of level, before corpses
            for (i in 0 until playernum) {
                if (players[i].mo!!._x == mthing.x.toInt() shl FRACBITS && players[i].mo!!._y == mthing.y.toInt() shl FRACBITS) {
                    return false
                }
            }
            return true
        }
        val x = mthing.x.toInt() shl FRACBITS
        val y = mthing.y.toInt() shl FRACBITS
        P_CheckPosition@ run {
            if (!actions.CheckPosition(players[playernum].mo!!, x, y)) {
                return false
            }
        }

        // flush an old corpse if needed
        if (bodyqueslot >= BODYQUESIZE) {
            P_RemoveMobj@ run {
                actions.RemoveMobj(bodyque[bodyqueslot % BODYQUESIZE]!!)
            }
        }
        bodyque[bodyqueslot % BODYQUESIZE] = players[playernum].mo!!
        bodyqueslot++

        // spawn a teleport fog
        var ss: subsector_t
        R_PointInSubsector@ run {
            ss = levelLoader.PointInSubsector(x, y)
        }
        // Angles stored in things are supposed to be "sanitized" against rollovers.
        val angle = (Tables.ANG45 * (mthing.angle / 45) ushr Tables.ANGLETOFINESHIFT).toInt()
        val mo = 
        P_SpawnMobj@ run {
            actions.SpawnMobj(
                x + 20 * Tables.finecosine[angle],
                y + 20 * Tables.finesine[angle],
                ss.sector!!.floorheight,
                mobjtype_t.MT_TFOG
            )
        }

        // FIXME: maybe false fix
        if (players[consoleplayer].viewz != 1) {
            S_StartSound@ run {
                doomSound.StartSound(mo, sfxenum_t.sfx_telept) // don't start sound on first frame
            }
        }
        return true
    }

    //
    // G_DeathMatchSpawnPlayer
    // Spawns a player at one of the random death match spots
    // called at level load and each death
    //
    @SourceCode.Exact
    @G_Game.C(G_Game.G_DeathMatchSpawnPlayer)
    override fun DeathMatchSpawnPlayer(playernum: Int) {
        val selections = deathmatch_p
        if (selections < 4) {
            I_Error@ run {
                doomSystem.Error("Only %d deathmatch spots, 4 required", selections)
            }
        }
        for (j in 0..19) {
            var i: Int
            P_Random@ run {
                i = random.P_Random() % selections
            }
            G_CheckSpot@ run {
                if (CheckSpot(playernum, deathmatchstarts[i]!!)) {
                    deathmatchstarts[i]!!.type = (playernum + 1).toShort()
                    P_SpawnPlayer@ run {
                        actions.SpawnPlayer(deathmatchstarts[i]!!)
                    }
                    return
                }
            }
        }

        // no good spot, so the player will probably get stuck
        // MAES: seriously, fuck him.
        P_SpawnPlayer@ run {
            actions.SpawnPlayer(playerstarts[playernum]!!)
        }
    }

    /**
     * G_DoReborn
     */
    @SourceCode.Exact
    @G_Game.C(G_Game.G_DoReborn)
    fun DoReborn(playernum: Int) {
        if (!netgame) {
            // reload the level from scratch
            gameaction = gameaction_t.ga_loadlevel
        } else {
            // respawn at the start

            // first dissasociate the corpse
            players[playernum].mo!!.player = null

            // spawn at random spot if in death match
            if (deathmatch) {
                G_DeathMatchSpawnPlayer@ run {
                    DeathMatchSpawnPlayer(playernum)
                }
                return
            }
            G_CheckSpot@ run {
                if (CheckSpot(playernum, playerstarts[playernum]!!)) {
                    P_SpawnPlayer@ run {
                        actions.SpawnPlayer(playerstarts[playernum]!!)
                    }
                    return
                }
            }

            // try to spawn at one of the other players spots
            for (i in 0 until Limits.MAXPLAYERS) {
                G_CheckSpot@ run {
                    if (CheckSpot(playernum, playerstarts[i]!!)) {
                        playerstarts[i]!!.type = (playernum + 1).toShort() // fake as other player
                        P_SpawnPlayer@ run {
                            actions.SpawnPlayer(playerstarts[i]!!)
                        }
                        playerstarts[i]!!.type = (i + 1).toShort() // restore
                        return
                    }
                }
                // he's going to be inside something.  Too bad.
                // MAES: Yeah, they're like, fuck him.
            }
            P_SpawnPlayer@ run {
                actions.SpawnPlayer(playerstarts[playernum]!!)
            }
        }
    }

    /** DOOM Par Times [4][10]  */
    val pars = arrayOf(
        intArrayOf(0),
        intArrayOf(0, 30, 75, 120, 90, 165, 180, 180, 30, 165),
        intArrayOf(0, 90, 90, 90, 120, 90, 360, 240, 30, 170),
        intArrayOf(0, 90, 45, 90, 150, 90, 90, 165, 30, 135)
    )

    /** DOOM II Par Times  */
    val cpars = intArrayOf(
        30, 90, 120, 120, 90, 150, 120, 120, 270, 90,  //  1-10
        210, 150, 150, 150, 210, 150, 420, 150, 210, 150,  // 11-20
        240, 150, 180, 150, 150, 300, 330, 420, 300, 180,  // 21-30
        120, 30 // 31-32
    )

    //
    // G_DoCompleted
    //
    var secretexit = false
    override fun ExitLevel() {
        secretexit = false
        gameaction = gameaction_t.ga_completed
    }

    // Here's for the german edition.
    fun SecretExitLevel() {
        // IF NO WOLF3D LEVELS, NO SECRET EXIT!
        secretexit = !(isCommercial() && (wadLoader.CheckNumForName("MAP31") < 0))
        gameaction = gameaction_t.ga_completed
    }

    @SourceCode.Exact
    @G_Game.C(G_Game.G_DoCompleted)
    protected fun DoCompleted() {
        gameaction = gameaction_t.ga_nothing
        for (i in 0 until Limits.MAXPLAYERS) {
            if (playeringame[i]) {
                G_PlayerFinishLevel@ run { // take away cards and stuff
                    players[i].PlayerFinishLevel()
                }
            }
        }
        if (automapactive) {
            AM_Stop@ run {
                autoMap.Stop()
            }
        }
        if (!isCommercial()) {
            when (gamemap) {
                8 -> {
                    // MAES: end of episode
                    gameaction = gameaction_t.ga_victory
                    return
                }
                9 ->                     // MAES: end of secret level
                {
                    players.apply({ it.didsecret = true })
                }
                else -> {}
            }
        }
        wminfo.didsecret = players[consoleplayer].didsecret
        wminfo.epsd = gameepisode - 1
        wminfo.last = gamemap - 1

        // wminfo.next is 0 biased, unlike gamemap
        if (isCommercial()) {
            if (secretexit) {
                when (gamemap) {
                    2 -> wminfo.next = 32 //Fix Doom 3 BFG Edition, MAP02 secret exit to MAP33 Betray
                    15 -> wminfo.next = 30
                    31 -> wminfo.next = 31
                    else -> {}
                }
            } else when (gamemap) {
                31, 32 -> wminfo.next = 15
                33 -> wminfo.next = 2 //Fix Doom 3 BFG Edition, MAP33 Betray exit back to MAP03
                else -> wminfo.next = gamemap
            }
        } else {
            if (secretexit) {
                wminfo.next = 8 // go to secret level
            } else if (gamemap == 9) {
                // returning from secret level
                when (gameepisode) {
                    1 -> wminfo.next = 3
                    2 -> wminfo.next = 5
                    3 -> wminfo.next = 6
                    4 -> wminfo.next = 2
                    else -> {}
                }
            } else {
                wminfo.next = gamemap // go to next level
            }
        }
        wminfo.maxkills = totalkills
        wminfo.maxitems = totalitems
        wminfo.maxsecret = totalsecret
        wminfo.maxfrags = 0
        if (isCommercial()) {
            wminfo.partime = 35 * cpars[gamemap - 1]
        } else if (gameepisode >= pars.size) {
            wminfo.partime = 0
        } else {
            wminfo.partime = 35 * pars[gameepisode][gamemap]
        }
        wminfo.pnum = consoleplayer
        for (i in 0 until Limits.MAXPLAYERS) {
            wminfo.plyr[i].`in` = playeringame[i]
            wminfo.plyr[i].skills = players[i].killcount
            wminfo.plyr[i].sitems = players[i].itemcount
            wminfo.plyr[i].ssecret = players[i].secretcount
            wminfo.plyr[i].stime = leveltime
            C2JUtils.memcpy(wminfo.plyr[i].frags, players[i].frags, wminfo.plyr[i].frags.size)
        }
        gamestate = GS_INTERMISSION
        viewactive = false
        automapactive = false
        if (statcopy != null) {
            C2JUtils.memcpy(statcopy, wminfo, 1)
        }
        WI_Start@ run {
            endLevel.Start(wminfo)
        }
    }

    /**
     * G_WorldDone
     */
    override fun WorldDone() {
        gameaction = gameaction_t.ga_worlddone
        if (secretexit) {
            players[consoleplayer].didsecret = true
        }
        if (isCommercial()) {
            when (gamemap) {
                15, 31 -> {
                    if (secretexit) {
                        finale.StartFinale()
                    }
                    
                }
                6, 11, 20, 30 -> finale.StartFinale()
            }
        }
    }

    fun DoWorldDone() {
        gamestate = GS_LEVEL
        gamemap = wminfo.next + 1
        DoLoadLevel()
        gameaction = gameaction_t.ga_nothing
        viewactive = true
    }

    //
    // G_InitFromSavegame
    // Can be called by the startup code or the menu task.
    //
    //extern boolean setsizeneeded;
    //void R_ExecuteSetViewSize (void);
    var savename: String? = null
    override fun LoadGame(name: String?) {
        savename = name
        gameaction = gameaction_t.ga_loadgame
    }

    /**
     * This is fugly. Making a "savegame object" will make at least certain comparisons easier, and avoid writing code
     * twice.
     */
    @Suspicious(CauseOfDesyncProbability.MEDIUM)
    @G_Game.C(G_Game.G_DoLoadGame)
    protected fun DoLoadGame() {
        try {
            val vcheck = StringBuffer()
            val header = VanillaDSGHeader()
            val dsg: IDoomSaveGame = VanillaDSG<T, V>(this)
            gameaction = gameaction_t.ga_nothing
            var f = DataInputStream(BufferedInputStream(FileInputStream(savename)))
            header.read(f)
            f.close()

            // skip the description field
            vcheck.append("version ")
            vcheck.append(Defines.VERSION)
            if (vcheck.toString().compareTo(header.getVersion()!!) != 0) {
                f.close()
                return  // bad version
            }

            // Ok so far, reopen stream.
            f = DataInputStream(BufferedInputStream(FileInputStream(savename)))
            gameskill = header.getGameskill()
            gameepisode = header.getGameepisode()
            gamemap = header.getGamemap()
            System.arraycopy(header.getPlayeringame(), 0, playeringame, 0, Limits.MAXPLAYERS)

            // load a base level
            G_InitNew@ run {
                InitNew(gameskill, gameepisode, gamemap)
            }
            if (gameaction == gameaction_t.ga_failure) {
                // failure to load. Abort.
                f.close()
                return
            }
            gameaction = gameaction_t.ga_nothing

            // get the times
            leveltime = header.getLeveltime()
            var ok: Boolean
            // dearchive all the modifications
            P_UnArchivePlayers@ P_UnArchiveWorld@ P_UnArchiveThinkers@ P_UnArchiveSpecials@ run {
                ok = dsg.doLoad(f)
            }
            f.close()

            // MAES: this will cause a forced exit.
            // The problem is that the status will have already been altered
            // (perhaps VERY badly) so it makes no sense to progress.
            // If you want it bullet-proof, you could implement
            // a "tentative loading" subsystem, which will only alter the game
            // if everything works out without errors. But who cares :-p
            if (!ok) {
                I_Error@ run {
                    doomSystem.Error("Bad savegame")
                }
            }

            // done
            //Z_Free (savebuffer);
            if (sceneRenderer.getSetSizeNeeded()) {
                R_ExecuteSetViewSize@ run {
                    sceneRenderer.ExecuteSetViewSize()
                }
            }

            // draw the pattern into the back screen
            R_FillBackScreen@ run {
                sceneRenderer.FillBackScreen()
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    //
    // G_SaveGame
    // Called by the menu task.
    // Description is a 24 byte text string
    //
    override fun SaveGame(slot: Int, description: String) {
        savegameslot = slot
        savedescription = description
        sendsave = true
    }

    @Suspicious(CauseOfDesyncProbability.LOW)
    @G_Game.C(G_Game.G_DoSaveGame)
    protected fun DoSaveGame() {
        try {
            val name: String
            //char[]    name2=new char[VERSIONSIZE];

            val build = StringBuffer()
            val header: IDoomSaveGameHeader = VanillaDSGHeader()
            val dsg: IDoomSaveGame = VanillaDSG<T, V>(this)
            M_CheckParm@ run {
                if (cVarManager.bool(CommandVariable.CDROM)) {
                    build.append("c:\\doomdata\\")
                }
            }
            build.append(String.format("%s%d.dsg", dstrings.SAVEGAMENAME, savegameslot))
            name = build.toString()
            val description = savedescription
            header.setName(description)
            header.setVersion(String.format("version %d", Defines.VERSION))
            header.setGameskill(gameskill)
            header.setGameepisode(gameepisode)
            header.setGamemap(gamemap)
            header.setPlayeringame(playeringame)
            header.setLeveltime(leveltime)
            dsg.setHeader(header)
            DataOutputStream(FileOutputStream(name)).use { f ->
                P_ArchivePlayers@ P_ArchiveWorld@ P_ArchiveThinkers@ P_ArchiveSpecials@ run {
                    val ok = dsg.doSave(f)
                }
            }
        } catch (e: IOException) {
            e.printStackTrace()
        }
        // Saving is not as destructive as loading.
        gameaction = gameaction_t.ga_nothing
        savedescription = ""
        players[consoleplayer].message = englsh.GGSAVED

        // draw the pattern into the back screen
        R_FillBackScreen@ run {
            sceneRenderer.FillBackScreen()
        }
    }

    var d_skill: skill_t? = null
    var d_episode = 0
    var d_map = 0
    override fun DeferedInitNew(skill: skill_t?, episode: Int, map: Int) {
        d_skill = skill
        d_episode = episode
        d_map = map
        gameaction = gameaction_t.ga_newgame
    }

    @SourceCode.Exact
    @G_Game.C(G_Game.G_DoNewGame)
    fun DoNewGame() {
        demoplayback = false
        netdemo = false
        netgame = false
        deathmatch = false
        playeringame[3] = false
        playeringame[2] = playeringame[3]
        playeringame[1] = playeringame[2]
        respawnparm = false
        fastparm = false
        nomonsters = false
        consoleplayer = 0
        G_InitNew@ run {
            InitNew(d_skill, d_episode, d_map)
        }
        gameaction = gameaction_t.ga_nothing
    }

    /**
     * G_InitNew
     * Can be called by the startup code or the menu task,
     * consoleplayer, displayplayer, playeringame[] should be set.
     */
    @Compatible
    @G_Game.C(G_Game.G_InitNew)
    fun InitNew(skill: skill_t?, episode: Int, map: Int) {
        InitNew(skill!!, episode, map, false)
    }

    private fun InitNew(skill: skill_t, episode: Int, map: Int, noSwitchRandom: Boolean) {
        var skill = skill
        var episode = episode
        var map = map
        if (_paused) {
            _paused = false
            S_ResumeSound@ run {
                doomSound.ResumeSound()
            }
        }
        if (skill.ordinal > skill_t.sk_nightmare.ordinal) {
            skill = skill_t.sk_nightmare
        }

        // This was quite messy with SPECIAL and commented parts.
        // Supposedly hacks to make the latest edition work.
        // It might not work properly.
        if (episode < 1) {
            episode = 1
        }
        if (isRetail()) {
            if (episode > 4) {
                episode = 4
            }
        } else if (isShareware()) {
            if (episode > 1) {
                episode = 1 // only start episode 1 on shareware
            }
        } else {
            if (episode > 3) {
                episode = 3
            }
        }
        if (map < 1) map = 1
        if (map > 9 && !isCommercial()) {
            map = 9
        }
        /**
         * I wrote it that way. No worries JavaRandom will never be picked on vanilla demo playback
         * - Good Sign 2017/05/08
         *
         * @SourceCode.Compatible
         */
        if (!noSwitchRandom) {
            if (cVarManager.bool(CommandVariable.JAVARANDOM)) {
                random.requireRandom(Defines.VERSION or Defines.JAVARANDOM_MASK)
            } else {
                random.requireRandom(Defines.VERSION)
            }
        }
        M_ClearRandom@ run {
            random.ClearRandom()
        }
        respawnmonsters = skill == skill_t.sk_nightmare || respawnparm

        // If on nightmare/fast monsters make everything MOAR pimp.
        if (fastparm || skill == skill_t.sk_nightmare && gameskill != skill_t.sk_nightmare) {
            for (i in statenum_t.S_SARG_RUN1.ordinal..statenum_t.S_SARG_PAIN2.ordinal) {
                info.states[i].tics = info.states[i].tics shr 1
            }
            info.mobjinfo[mobjtype_t.MT_BRUISERSHOT.ordinal].speed = 20 * MAPFRACUNIT
            info.mobjinfo[mobjtype_t.MT_HEADSHOT.ordinal].speed = 20 * MAPFRACUNIT
            info.mobjinfo[mobjtype_t.MT_TROOPSHOT.ordinal].speed = 20 * MAPFRACUNIT
        } else if (skill != skill_t.sk_nightmare && gameskill == skill_t.sk_nightmare) {
            for (i in statenum_t.S_SARG_RUN1.ordinal..statenum_t.S_SARG_PAIN2.ordinal) {
                info.states[i].tics = info.states[i].tics shl 1
            }
            info.mobjinfo[mobjtype_t.MT_BRUISERSHOT.ordinal].speed = 15 * MAPFRACUNIT
            info.mobjinfo[mobjtype_t.MT_HEADSHOT.ordinal].speed = 10 * MAPFRACUNIT
            info.mobjinfo[mobjtype_t.MT_TROOPSHOT.ordinal].speed = 10 * MAPFRACUNIT
        }

        // force players to be initialized upon first level load
        for (i in 0 until Limits.MAXPLAYERS) {
            players[i].playerstate = Defines.PST_REBORN
        }

        // will be set false if a demo
        usergame = true
        _paused = false
        demoplayback = false
        automapactive = false
        viewactive = true
        gameepisode = episode
        gamemap = map
        gameskill = skill
        viewactive = true

        // set the sky map for the episode
        if (isCommercial()) {
            textureManager.setSkyTexture(textureManager.TextureNumForName("SKY3"))
            if (gamemap < 12) {
                textureManager.setSkyTexture(textureManager.TextureNumForName("SKY1"))
            } else if (gamemap < 21) {
                textureManager.setSkyTexture(textureManager.TextureNumForName("SKY2"))
            }
        } else {
            when (episode) {
                1 -> textureManager.setSkyTexture(textureManager.TextureNumForName("SKY1"))
                2 -> textureManager.setSkyTexture(textureManager.TextureNumForName("SKY2"))
                3 -> textureManager.setSkyTexture(textureManager.TextureNumForName("SKY3"))
                4 -> textureManager.setSkyTexture(textureManager.TextureNumForName("SKY4"))
                else -> {}
            }
        }
        G_DoLoadLevel@ run {
            if (!DoLoadLevel()) {
                levelLoadFailure()
            }
        }
    }

    protected fun levelLoadFailure() {
        val endgame = doomSystem.GenerateAlert(Strings.LEVEL_FAILURE_TITLE, Strings.LEVEL_FAILURE_CAUSE)

        // Initiate endgame
        if (endgame) {
            gameaction = gameaction_t.ga_failure
            gamestate = GS_DEMOSCREEN
            menu.ClearMenus()
            StartTitle()
        } else {
            // Shutdown immediately.
            doomSystem.Quit()
        }
    }

    //
    // DEMO RECORDING
    //
    fun ReadDemoTiccmd(cmd: ticcmd_t) {
        val democmd = demobuffer!!.getNextTic()
        if (democmd == null) {
            // end of demo data stream
            CheckDemoStatus()

            // Force status resetting
            demobuffer!!.resetDemo()
            return
        }
        democmd.decode(cmd)
    }

    fun WriteDemoTiccmd(cmd: ticcmd_t) {
        // press q to end demo recording
        if (gamekeydown[key_recordstop]) {
            CheckDemoStatus()
        }
        val reccmd: IDemoTicCmd = VanillaTiccmd()
        reccmd.encode(cmd)
        demobuffer!!.putTic(reccmd)

        // MAES: Useless, we can't run out of space anymore (at least not in theory).

        /*   demobuffer[demo_p++] = cmd.forwardmove;
     demobuffer[demo_p++] = cmd.sidemove;
     demobuffer[demo_p++] = (byte) ((cmd.angleturn+128)>>8);
     demobuffer[demo_p++] = (byte) cmd.buttons;
     demo_p -= 4;
     if (demo_p > demoend - 16)
     {
     // no more space
     CheckDemoStatus ();
     return;
     } */

        //ReadDemoTiccmd (cmd);         // make SURE it is exactly the same
        // MAES: this is NOT the way to do in Mocha, because we are not manipulating
        // the demo index directly anymore. Instead, decode what we have just saved.
        reccmd.decode(cmd)
    }

    /**
     * G_RecordDemo
     */
    fun RecordDemo(name: String?) {
        val buf = StringBuffer()
        usergame = false
        buf.append(name)
        buf.append(".lmp")
        demoname = buf.toString()
        demobuffer = VanillaDoomDemo()
        demorecording = true
    }

    @G_Game.C(G_Game.G_BeginRecording)
    fun BeginRecording() {
        val demobuffer = demobuffer!!
        demobuffer.setVersion(
            if (cVarManager.bool(CommandVariable.JAVARANDOM)) Defines.VERSION or Defines.JAVARANDOM_MASK else Defines.VERSION
        )
        demobuffer.setSkill(gameskill)
        demobuffer.setEpisode(gameepisode)
        demobuffer.setMap(gamemap)
        demobuffer.setDeathmatch(deathmatch)
        demobuffer.setRespawnparm(respawnparm)
        demobuffer.setFastparm(fastparm)
        demobuffer.setNomonsters(nomonsters)
        demobuffer.setConsoleplayer(consoleplayer)
        demobuffer.setPlayeringame(playeringame)
    }

    var defdemoname: String? = null

    /**
     * G_PlayDemo
     */
    fun DeferedPlayDemo(name: String?) {
        defdemoname = name
        gameaction = gameaction_t.ga_playdemo
    }

    @Compatible
    @G_Game.C(G_Game.G_DoPlayDemo)
    fun DoPlayDemo() {
        val skill: skill_t
        var fail: Boolean
        var i: Int
        val episode: Int
        val map: Int
        gameaction = gameaction_t.ga_nothing
        // MAES: Yeah, it's OO all the way now, baby ;-)
        W_CacheLumpName@ run {
            try {
                demobuffer = wadLoader.CacheLumpName(
                    defdemoname!!.uppercase(Locale.getDefault()),
                    Defines.PU_STATIC,
                    VanillaDoomDemo::class.java
                )
            } catch (e: Exception) {
                fail = true
            }
        }
        val demobuffer = demobuffer!!
        fail = demobuffer.getSkill() == null
        var version: Int = 0
        if (fail || demobuffer.getVersion() and 0xFF.also {
                version = it
            } and Defines.JAVARANDOM_MASK.inv() != Defines.VERSION) {
            System.err.println("Demo is from a different game version!\n")
            System.err.println("Version code read: " + demobuffer.getVersion())
            gameaction = gameaction_t.ga_nothing
            return
        }
        random.requireRandom(version)
        skill = demobuffer.getSkill()!!
        episode = demobuffer.getEpisode()
        map = demobuffer.getMap()
        deathmatch = demobuffer.isDeathmatch()
        respawnparm = demobuffer.isRespawnparm()
        fastparm = demobuffer.isFastparm()
        nomonsters = demobuffer.isNomonsters()
        consoleplayer = demobuffer.getConsoleplayer()
        // Do this, otherwise previously loaded demos will be stuck at their end.
        demobuffer.resetDemo()
        val pigs = demobuffer.getPlayeringame()

        playeringame.transformIndexed({ index ->  pigs[index] }, Limits.MAXPLAYERS )

        if (playeringame[1]) {
            netgame = true
            netdemo = true
        }

        // don't spend a lot of time in loadlevel
        precache = false
        G_InitNew@ run {
            InitNew(skill, episode, map, true)
        }
        precache = true
        usergame = false
        demoplayback = true
    }

    //
    // G_TimeDemo
    //
    fun TimeDemo(name: String?) {
        nodrawers = cVarManager.bool(CommandVariable.NODRAW)
        noblit = cVarManager.bool(CommandVariable.NOBLIT)
        timingdemo = true
        singletics = true
        defdemoname = name
        gameaction = gameaction_t.ga_playdemo
    }

    /** G_CheckDemoStatus
     *
     * Called after a death or level completion to allow demos to be cleaned up
     * Returns true if a new demo loop action will take place
     *
     */
    override fun CheckDemoStatus(): Boolean {
        val endtime: Int
        if (timingdemo) {
            endtime = RealTime.GetTime()
            // killough -- added fps information and made it work for longer demos:
            val realtics = (endtime - starttime).toLong()
            commit()
            CM.SaveDefaults()
            doomSystem.Error(
                "timed %d gametics in %d realtics = %f frames per second",
                gametic,
                realtics,
                gametic * Defines.TICRATE.toDouble() / realtics
            )
        }
        if (demoplayback) {
            if (singledemo) doomSystem.Quit()

            // Z_ChangeTag (demobuffer, PU_CACHE);
            demoplayback = false
            netdemo = false
            netgame = false
            deathmatch = false
            playeringame[3] = false
            playeringame[2] = playeringame[3]
            playeringame[1] = playeringame[2]
            respawnparm = false
            fastparm = false
            nomonsters = false
            consoleplayer = 0
            AdvanceDemo()
            return true
        }
        if (demorecording) {
            //demobuffer[demo_p++] = (byte) DEMOMARKER;
            MenuMisc.WriteFile(demoname, demobuffer as IWritableDoomObject)
            //Z_Free (demobuffer);
            demorecording = false
            doomSystem.Error("Demo %s recorded", demoname)
        }
        return false
    }

    /** This should always be available for real timing  */
    protected var RealTime: ITicker

    // Bookkeeping on players - state.
    lateinit var players: Array<player_t>
    var random: DelegateRandom
    val cVarManager: CVarManager
    val wadLoader: IWadLoader
    val doomSound: IDoomSound
    val soundDriver: ISoundDriver
    val music: IMusic
    val statusBar: AbstractStatusBar
    val graphicSystem: DoomGraphicSystem<T, V>
    val systemNetworking: DoomSystemNetworking
    val gameNetworking: IDoomGameNetworking
    val levelLoader: AbstractLevelLoader
    val menu: IDoomMenu
    val actions: ActionFunctions
    val sceneRenderer: SceneRenderer<T, V>
    val headsUp: HU
    val autoMap: IAutoMap<T, V>
    val finale: Finale<T>
    val endLevel: EndLevel<T, V>
    val wiper: Wiper
    val textureManager: TextureManager<T>
    val spriteManager: ISpriteManager
    val ticker: ITicker
    val diskDrawer: IDiskDrawer
    val doomSystem: IDoomSystem
    val bppMode: BppMode
    override fun update() {
        super.update()
        // Video...so you should wait until video renderer is active.
        graphicSystem.setUsegamma(CM.getValue(Settings.usegamma, Int::class.java))

        // These should really be handled by the menu.
        menu.showMessages = CM.equals(Settings.show_messages, 1)
        menu.screenBlocks = CM.getValue(Settings.screenblocks, Int::class.java)

        // These should be handled by the HU
        for (i in 0..9) {
            val chatmacro = String.format("chatmacro%d", i)
            headsUp.setChatMacro(i, CM.getValue(Settings.valueOf(chatmacro), String::class.java))
        }
    }

    override fun commit() {
        super.commit()
        // Video...
        CM.update(Settings.usegamma, graphicSystem.getUsegamma())

        // These should really be handled by the menu.
        CM.update(Settings.show_messages, menu.showMessages)
        CM.update(Settings.screenblocks, menu.screenBlocks)

        // These should be handled by the HU
        for (i in 0..9) {
            CM.update(Settings.valueOf(String.format("chatmacro%d", i)), headsUp.chat_macros[i])
        }
    }

    @Throws(IOException::class)
    fun setupLoop() {
        // check for a driver that wants intermission stats
        cVarManager.with(CommandVariable.STATCOPY, 0) { s: String ->
            // TODO: this should be chained to a logger
            statcopy = s
            print("External statistics registered.\n")
        }

        // start the apropriate game based on parms
        cVarManager.with(CommandVariable.RECORD, 0, Consumer { s: String? ->
            RecordDemo(s)
            autostart = true
        })

        //p = CM.CheckParm ("-timedemo");
        ChooseLoop@ run {
            if (singletics) {
                TimeDemo(loaddemo)
                autostart = true
                return@run  // DoomLoop();  // never returns
            }
            if (fastdemo || normaldemo) {
                singledemo = true // quit after one demo
                if (fastdemo) {
                    timingdemo = true
                }
                InitNew(startskill, startepisode, startmap)
                gamestate = GS_DEMOSCREEN
                DeferedPlayDemo(loaddemo)
                return@run  // DoomLoop();  // never returns
            }
            if (gameaction != gameaction_t.ga_loadgame) {
                if (autostart || netgame) {
                    InitNew(startskill, startepisode, startmap)
                } else {
                    StartTitle() // start up intro loop
                }
            }
        }
        DoomLoop() // never returns
    }

    private fun printGameInfo() {
        // Iff additonal PWAD files are used, print modified banner
        if (modifiedgame) // Generate WAD loading alert. Abort upon denial.
        {
            if (!doomSystem.GenerateAlert(Strings.MODIFIED_GAME_TITLE, Strings.MODIFIED_GAME_DIALOG)) {
                wadLoader.CloseAllHandles()
                System.exit(-2)
            }
        }
        when (getGameMode()) {
            GameMode.shareware, GameMode.indetermined -> {
                print("===========================================================================\n")
                print("                                Shareware!\n")
                print("===========================================================================\n")
            }
            GameMode.registered, GameMode.retail, GameMode.commercial, GameMode.pack_tnt, GameMode.pack_plut, GameMode.pack_xbla -> {
                print("===========================================================================\n")
                print("                 Commercial product - do not distribute!\n")
                print("         Please report software piracy to the SPA: 1-800-388-PIR8\n")
                print("===========================================================================\n")
            }
            GameMode.freedoom1, GameMode.freedoom2, GameMode.freedm -> {
                print("===========================================================================\n")
                print("       Copyright © 2001-2017 Contributors to the Freedoom project.\n")
                print("                            All rights reserved.\n")
                print("     See: https://github.com/freedoom/freedoom/blob/master/COPYING.adoc\n")
                print("===========================================================================\n")
            }
            else -> {}
        }
    }

    private fun readCVars() {
        /**
         * D_DoomMain
         *
         * Completes the job started by Init. Here everything priority-critical is called and created in more detail.
         */
        val file = StringBuffer()
        val iwadfilename = IdentifyVersion()
        nomonsters = cVarManager.bool(CommandVariable.NOMONSTERS)
        respawnparm = cVarManager.bool(CommandVariable.RESPAWN)
        fastparm = cVarManager.bool(CommandVariable.FAST)
        devparm = cVarManager.bool(CommandVariable.DEVPARM)
        if (!cVarManager.bool(CommandVariable.ALTDEATH).also { altdeath = it }) {
            deathmatch = cVarManager.bool(CommandVariable.DEATHMATCH)
        }

        // MAES: Check for Ultimate Doom in "doom.wad" filename.
        val tmpwad = WadLoader()
        try {
            tmpwad.InitFile(iwadfilename)
        } catch (e2: Exception) {
            // TODO Auto-generated catch block
            e2.printStackTrace()
        }
        // Check using a reloadable hack.
        CheckForUltimateDoom(tmpwad)
        // MAES: better extract a method for this.
        GenerateTitle()
        // Print ticker info. It has already been set at Init() though.
        if (cVarManager.bool(CommandVariable.MILLIS)) {
            println("ITicker: Using millisecond accuracy timer.")
        } else if (cVarManager.bool(CommandVariable.FASTTIC)) {
            println("ITicker: Using fastest possible timer.")
        } else {
            println("ITicker: Using nanosecond accuracy timer.")
        }
        println(title.toString())
        if (devparm) {
            println(englsh.D_DEVSTR)
        }
        // Running from CDROM?
        if (cVarManager.bool(CommandVariable.CDROM)) {
            println(englsh.D_CDROM)
            //System.get("c:\\doomdata",0);
            //System.out.println (Settings.basedefault+"c:/doomdata/default.cfg");
        }
        // turbo option
        if (cVarManager.specified(CommandVariable.TURBO)) {
            var scale = 200
            if (cVarManager.present(CommandVariable.TURBO)) {
                scale = cVarManager.get(CommandVariable.TURBO, Int::class.java, 0).get()
            }
            if (scale < 10) {
                scale = 10
            }
            if (scale > 400) {
                scale = 400
            }
            println("turbo scale: $scale")
            forwardmove[0] = forwardmove[0] * scale / 100
            forwardmove[1] = forwardmove[1] * scale / 100
            sidemove[0] = sidemove[0] * scale / 100
            sidemove[1] = sidemove[1] * scale / 100
        }
        // add any files specified on the command line with -file wadfile
        // to the wad list
        //
        // convenience hack to allow -wart e m to add a wad file
        // prepend a tilde to the filename so wadfile will be reloadable
        if (cVarManager.present(CommandVariable.WART)) {
            val ep = cVarManager.get(CommandVariable.WART, Int::class.java, 0).get()
            val map = cVarManager.get(CommandVariable.WART, Int::class.java, 1).get()
            cVarManager.override(CommandVariable.WARP, WarpFormat(ep * 10 + map), 0)
            val gamemode = getGameMode()
            when (gamemode) {
                GameMode.shareware, GameMode.retail, GameMode.registered, GameMode.freedoom1 -> {
                    file.append("~")
                    file.append(dstrings.DEVMAPS)
                    file.append(String.format("E%dM%d.wad", ep, map))
                    file.append(String.format("Warping to Episode %s, Map %s.\n", ep, map))
                }
                GameMode.commercial, GameMode.freedoom2, GameMode.freedm -> if (ep < 10) {
                    file.append("~")
                    file.append(dstrings.DEVMAPS)
                    file.append(String.format("cdata/map0%d.wad", ep))
                } else {
                    file.append("~")
                    file.append(dstrings.DEVMAPS)
                    file.append(String.format("cdata/map%d.wad", ep))
                }
                else -> if (ep < 10) {
                    file.append("~")
                    file.append(dstrings.DEVMAPS)
                    file.append(String.format("cdata/map0%d.wad", ep))
                } else {
                    file.append("~")
                    file.append(dstrings.DEVMAPS)
                    file.append(String.format("cdata/map%d.wad", ep))
                }
            }
            AddFile(file.toString())
        }
        if (cVarManager.present(CommandVariable.FILE)) {
            // the parms after p are wadfile/lump names,
            // until end of parms or another - preceded parm
            modifiedgame = true // homebrew levels
            cVarManager.with(CommandVariable.FILE, 0) { a: Array<String>? ->
                Arrays.stream(a)
                    .map { s -> C2JUtils.unquoteIfQuoted(s, '"') }
                    .forEach { file -> AddFile(file) }
            }
        }
        if (cVarManager.present(CommandVariable.PLAYDEMO)) {
            normaldemo = true
            loaddemo = cVarManager.get(CommandVariable.PLAYDEMO, String::class.java, 0).get()
        } else if (cVarManager.present(CommandVariable.FASTDEMO)) {
            println("Fastdemo mode. Boundless clock!")
            fastdemo = true
            loaddemo = cVarManager.get(CommandVariable.FASTDEMO, String::class.java, 0).get()
        } else if (cVarManager.present(CommandVariable.TIMEDEMO)) {
            singletics = true
            loaddemo = cVarManager.get(CommandVariable.TIMEDEMO, String::class.java, 0).get()
        }

        // If any of the previous succeeded, try grabbing the filename.
        if (loaddemo != null) {
            loaddemo = C2JUtils.unquoteIfQuoted(loaddemo!!, '"')
            AddFile("$loaddemo.lmp")
            System.out.printf("Playing demo %s.lmp.\n", loaddemo)
            autostart = true
        }

        // Subsequent uses of loaddemo use only the lump name.
        loaddemo = C2JUtils.extractFileBase(loaddemo, 0, true)
        // get skill / episode / map from parms
        // FIXME: should get them FROM THE DEMO itself.
        startskill = skill_t.sk_medium
        startepisode = 1
        startmap = 1
        //autostart = false;
        if (cVarManager.present(CommandVariable.NOVERT)) {
            novert = cVarManager.get(CommandVariable.NOVERT, ForbidFormat::class.java, 0)
                .filter { obj: ForbidFormat? -> ForbidFormat.FORBID.equals(obj) }
                .isPresent
            if (!novert) {
                println("-novert ENABLED (default)")
            } else {
                println("-novert DISABLED. Hope you know what you're doing...")
            }
        }
        cVarManager.with(CommandVariable.SKILL, 0) { s: Int ->
            startskill = skill_t.values()[s - 1]
            autostart = true
        }
        cVarManager.with(CommandVariable.EPISODE, 0) { ep: Int ->
            startepisode = ep
            startmap = 1
            autostart = true
        }
        if (cVarManager.present(CommandVariable.TIMER) && deathmatch) {
            // Good Sign (2017/03/31) How this should work?
            val time = cVarManager.get(CommandVariable.TIMER, Int::class.java, 0).get()
            print("Levels will end after $time minute")
            if (time > 1) {
                print("s")
            }
            print(".\n")
        }
        // OK, and exactly how is this enforced?
        if (cVarManager.bool(CommandVariable.AVG) && deathmatch) {
            print("Austin Virtual Gaming: Levels will end after 20 minutes\n")
        }

        // MAES 31/5/2011: added support for +map variation.
        cVarManager.with(CommandVariable.WARP, 0) { w: WarpFormat ->
            val metric = w.getMetric(isCommercial())
            startepisode = metric.getEpisode()
            startmap = metric.getMap()
            autostart = true
        }

        // Maes: 1/6/2011 Added +map support
        cVarManager.with(CommandVariable.MAP, 0) { m: MapFormat ->
            val metric = m.getMetric(isCommercial())
            startepisode = metric.getEpisode()
            startmap = metric.getMap()
            autostart = true
        }
        cVarManager.with(CommandVariable.LOADGAME, 0) { c: Char? ->
            file.delete(0, file.length)
            if (cVarManager.bool(CommandVariable.CDROM)) {
                file.append("c:\\doomdata\\")
            }
            file.append(String.format("%s%d.dsg", dstrings.SAVEGAMENAME, c))
            LoadGame(file.toString())
        }
    }
    /**
     * Since it's so intimately tied, it's less troublesome to merge the "main" and "network" code.
     */
    /** To be initialized by the DoomNetworkingInterface via a setter  */ //private  doomcom_t   doomcom;   
    //private  doomdata_t  netbuffer;      // points inside doomcom
    protected var sb = StringBuilder()

    //
    // NETWORKING
    //
    // gametic is the tic about to (or currently being) run
    // maketic is the tick that hasn't had control made for it yet
    // nettics[] has the maketics for all players 
    //
    // a gametic cannot be run until nettics[] > gametic for all players
    //
    //ticcmd_t[]  localcmds= new ticcmd_t[BACKUPTICS];
    //ticcmd_t [][]       netcmds=new ticcmd_t [MAXPLAYERS][BACKUPTICS];
    var nettics = IntArray(Limits.MAXNETNODES)
    var nodeingame = BooleanArray(Limits.MAXNETNODES) // set false as nodes leave game
    var remoteresend = BooleanArray(Limits.MAXNETNODES) // set when local needs tics
    var resendto = IntArray(Limits.MAXNETNODES) // set when remote needs tics
    var resendcount = IntArray(Limits.MAXNETNODES)
    var nodeforplayer = IntArray(Limits.MAXPLAYERS)
    var maketic = 0
    var lastnettic = 0
    var skiptics = 0
    protected var _ticdup = 0
    override fun getTicdup(): Int {
        return _ticdup
    }

    override fun setTicdup(ticdup: Int) {
        this._ticdup = ticdup
    }

    var maxsend // BACKUPTICS/(2*ticdup)-1;
            = 0

    //void D_ProcessEvents (void); 
    //void G_BuildTiccmd (ticcmd_t *cmd); 
    //void D_DoAdvanceDemo (void);
    // _D_
    var reboundpacket = false
    var reboundstore = doomdata_t()

    /**
     * MAES: interesting. After testing it was found to return the following size:
     * (8*(netbuffer.numtics+1));
     */
    fun NetbufferSize(): Int {
        //    return (int)(((doomdata_t)0).cmds[netbuffer.numtics]);
        return 8 * (netbuffer!!.numtics + 1)
    }

    protected fun NetbufferChecksum(): Long {
        // FIXME -endianess?
        if (Defines.NORMALUNIX) {
            return 0 // byte order problems
        }
        /**
         * Here it was trying to get the length of a doomdata_t struct up to retransmit from.
         * l = (NetbufferSize () - (int)&(((doomdata_t *)0)->retransmitfrom))/4;
         * (int)&(((doomdata_t *)0)->retransmitfrom) evaluates to "4"
         * Therefore, l= (netbuffersize - 4)/4
         */
        val l = (NetbufferSize() - 4) / 4
        var c = 0x1234567L
        for (i in 0 until l) { // TODO: checksum would be better computer in the netbuffer itself.
            // The C code actually takes all fields into account.
            c += 0 // TODO: (netbuffer->retransmitfrom)[i] * (i+1);
        }
        return c and NetConsts.NCMD_CHECKSUM.toLong()
    }

    protected fun ExpandTics(low: Int): Int {
        val delta: Int
        delta = low - (maketic and 0xff)
        if (delta >= -64 && delta <= 64) {
            return (maketic and 0xff.inv()) + low
        }
        if (delta > 64) {
            return (maketic and 0xff.inv()) - 256 + low
        }
        if (delta < -64) {
            return (maketic and 0xff.inv()) + 256 + low
        }
        doomSystem.Error("ExpandTics: strange value %d at maketic %d", low, maketic)
        return 0
    }

    /**
     * HSendPacket
     *
     * Will send out a packet to all involved parties. A special case is the rebound storage, which acts as a local
     * "echo" which is then picked up by the host itself. This is necessary to simulate a 1-node network.
     *
     * @throws IOException
     */
    fun HSendPacket(node: Int, flags: Int) {
        val netbuffer = netbuffer!!
        netbuffer.checksum = (NetbufferChecksum() or flags.toLong()).toInt()

        // Local node's comms are sent to rebound packet, which is 
        // then picked up again. THIS IS VITAL FOR SINGLE-PLAYER
        // SPEED THROTTLING TOO, AS IT RELIES ON NETWORK ACKS/BUSY
        // WAITING.
        if (node == 0) {
            // _D_
            reboundstore.copyFrom(netbuffer)
            reboundpacket = true
            return
        }
        if (demoplayback) {
            return
        }
        if (!netgame) {
            doomSystem.Error("Tried to transmit to another node")
        }
        val doomcom = doomcom!!
        doomcom.command = NetConsts.CMD_SEND
        doomcom.remotenode = node.toShort()
        doomcom.datalength = NetbufferSize().toShort()
        if (debugfile != null) {
            val debugfile = debugfile!!
            var i: Int
            val realretrans: Int
            realretrans = if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_RETRANSMIT)) {
                ExpandTics(netbuffer.retransmitfrom.toInt())
            } else {
                -1
            }
            logger(
                debugfile, "send (" + ExpandTics(netbuffer.starttic.toInt()) + ", " + netbuffer.numtics + ", R "
                        + realretrans + "[" + doomcom.datalength + "]"
            )

            doomcom.datalength.times {
                logger(
                    debugfile, """
     $netbuffer
     
     """.trimIndent()
                )
            }
        }

        // This should execute a "send" command for the current stuff in doomcom.
        systemNetworking.NetCmd()
    }

    //
    // HGetPacket
    // Returns false if no packet is waiting
    //
    private fun HGetPacket(): Boolean {
        // Fugly way of "clearing" the buffer.
        sb.setLength(0)
        val netbuffer = netbuffer!!
        val doomcom = doomcom!!

        if (reboundpacket) {
            // FIXME: MAES: this looks like a struct copy 
            netbuffer.copyFrom(reboundstore)
            doomcom.remotenode = 0
            reboundpacket = false
            return true
        }

        // If not actually a netgame (e.g. single player, demo) return.
        if (!netgame) return false
        if (demoplayback) return false
        doomcom.command = NetConsts.CMD_GET
        systemNetworking.NetCmd()

        // Invalid node?
        if (doomcom.remotenode.toInt() == -1) return false
        val debugfile = debugfile!!
        if (doomcom.datalength.toInt() != NetbufferSize()) {
            if (C2JUtils.eval(debugfile)) logger(
                debugfile, """
     bad packet length ${doomcom.datalength}
     
     """.trimIndent()
            )
            return false
        }
        if (NetbufferChecksum() != (netbuffer.checksum and NetConsts.NCMD_CHECKSUM).toLong()) {
            if (C2JUtils.eval(debugfile)) logger(debugfile, "bad packet checksum\n")
            return false
        }
        if (C2JUtils.eval(debugfile)) {
            val realretrans: Int

            if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_SETUP)) logger(
                debugfile,
                "setup packet\n"
            ) else {
                realretrans = if (C2JUtils.flags(
                        netbuffer.checksum,
                        NetConsts.NCMD_RETRANSMIT
                    )
                ) ExpandTics(netbuffer.retransmitfrom.toInt()) else -1
                sb.append("get ")
                sb.append(doomcom.remotenode.toInt())
                sb.append(" = (")
                sb.append(ExpandTics(netbuffer.starttic.toInt()))
                sb.append(" + ")
                sb.append(netbuffer.numtics.toInt())
                sb.append(", R ")
                sb.append(realretrans)
                sb.append(")[")
                sb.append(doomcom.datalength.toInt())
                sb.append("]")
                logger(debugfile, sb.toString())

                // Trick: force update of internal buffer.
                netbuffer.pack()
                /**
                 * TODO: Could it be actually writing stuff beyond the boundaries of a single doomdata object?
                 * A doomcom object has a lot of header info, and a single "raw" data placeholder, which by now
                 * should be inside netbuffer....right?
                 */
                try {
                    doomcom.datalength.times {
                        debugfile.write(Integer.toHexString(netbuffer.cached()[it].toInt()))
                        debugfile.write('\n'.code)
                    }
                } catch (e: IOException) {
                } // "Drown" IOExceptions here.
            }
        }
        return true
    }

    ////    GetPackets
    var exitmsg = StringBuilder(80)
    fun GetPackets() {
        var netconsole: Int
        var netnode: Int
        var src: ticcmd_t
        var dest: ticcmd_t
        var realend: Int
        var realstart: Int

        while (HGetPacket()) {
            val netbuffer = netbuffer!!
            if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_SETUP)) {
                continue  // extra setup packet
            }
            netconsole = netbuffer.player.toInt() and DoomStatus.PL_DRONE.inv()
            netnode = doomcom!!.remotenode.toInt()

            // to save bytes, only the low byte of tic numbers are sent
            // Figure out what the rest of the bytes are
            realstart = ExpandTics(netbuffer.starttic.toInt())
            realend = realstart + netbuffer.numtics

            // check for exiting the game
            if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_EXIT)) {
                if (!nodeingame[netnode]) {
                    continue
                }
                nodeingame[netnode] = false
                playeringame[netconsole] = false
                exitmsg.insert(0, "Player 1 left the game")
                exitmsg.setCharAt(7, (exitmsg[7].code + netconsole).toChar())
                players[consoleplayer].message = exitmsg.toString()
                if (demorecording) {
                    CheckDemoStatus()
                }
                continue
            }

            // check for a remote game kill
            if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_KILL)) {
                doomSystem.Error("Killed by network driver")
            }
            nodeforplayer[netconsole] = netnode

            // check for retransmit request
            if (resendcount[netnode] <= 0
                && C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_RETRANSMIT)
            ) {
                resendto[netnode] = ExpandTics(netbuffer.retransmitfrom.toInt())
                if (C2JUtils.eval(debugfile)) {
                    sb.setLength(0)
                    sb.append("retransmit from ")
                    sb.append(resendto[netnode])
                    sb.append('\n')
                    logger(debugfile!!, sb.toString())
                    resendcount[netnode] = DoomStatus.RESENDCOUNT
                }
            } else {
                resendcount[netnode]--
            }

            // check for out of order / duplicated packet       
            if (realend == nettics[netnode]) {
                continue
            }
            if (realend < nettics[netnode]) {
                if (C2JUtils.eval(debugfile)) {
                    sb.setLength(0)
                    sb.append("out of order packet (")
                    sb.append(realstart)
                    sb.append(" + ")
                    sb.append(netbuffer.numtics.toInt())
                    sb.append(")\n")
                    logger(debugfile!!, sb.toString())
                }
                continue
            }

            // check for a missed packet
            if (realstart > nettics[netnode]) {
                // stop processing until the other system resends the missed tics
                if (C2JUtils.eval(debugfile)) {
                    sb.setLength(0)
                    sb.append("missed tics from ")
                    sb.append(netnode)
                    sb.append(" (")
                    sb.append(realstart)
                    sb.append(" - ")
                    sb.append(nettics[netnode])
                    sb.append(")\n")
                    logger(debugfile!!, sb.toString())
                }
                remoteresend[netnode] = true
                continue
            }

            // update command store from the packet
            run {
                var start: Int
                remoteresend[netnode] = false
                start = nettics[netnode] - realstart
                src = netbuffer.cmds[start]
                while (nettics[netnode] < realend) {
                    dest = netcmds[netconsole][nettics[netnode] % Defines.BACKUPTICS]!!
                    nettics[netnode]++
                    // MAES: this is a struct copy.
                    src.copyTo(dest)
                    // Advance src
                    start++

                    //_D_: had to add this (see linuxdoom source). That fixed that damn consistency failure!!!
                    if (start < netbuffer.cmds.size) {
                        src = netbuffer.cmds[start]
                    }
                }
            }
        }
    }

    protected fun logger(debugfile: OutputStreamWriter, string: String?) {
        try {
            debugfile.write(string)
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    var gametime = 0
    override fun NetUpdate() {
        val nowtime: Int
        var newtics: Int
        var i: Int
        var j: Int
        var realstart: Int
        val gameticdiv: Int

        // check time
        nowtime = ticker.GetTime() / _ticdup
        newtics = nowtime - gametime
        gametime = nowtime
        if (newtics <= 0) { // nothing new to update
            // listen for other packets
            GetPackets()
        } else {
            if (skiptics <= newtics) {
                newtics -= skiptics
                skiptics = 0
            } else {
                skiptics -= newtics
                newtics = 0
            }
            val netbuffer = netbuffer!!
            netbuffer.player = consoleplayer.toByte()

            // build new ticcmds for console player
            gameticdiv = gametic / _ticdup
            i = 0
            while (i < newtics) {

                //videoInterface.StartTic();
                ProcessEvents()
                if (maketic - gameticdiv >= Defines.BACKUPTICS / 2 - 1) {
                    break // can't hold any more
                }
                //System.out.printf ("mk:%d ",maketic);
                BuildTiccmd(localcmds[maketic % Defines.BACKUPTICS]!!)
                maketic++
                i++
            }
            if (singletics) {
                return  // singletic update is syncronous
            }
            // send the packet to the other nodes
            i = 0
            val doomcom = doomcom!!
            while (i < doomcom.numnodes) {
                if (nodeingame[i]) {
                    netbuffer.starttic = resendto[i].also { realstart = it }.toByte()
                    netbuffer.numtics = (maketic - realstart).toByte()
                    if (netbuffer.numtics > Defines.BACKUPTICS) {
                        doomSystem.Error("NetUpdate: netbuffer.numtics > BACKUPTICS")
                    }
                    resendto[i] = maketic - doomcom.extratics
                    j = 0
                    while (j < netbuffer.numtics) {
                        localcmds[(realstart + j) % Defines.BACKUPTICS]!!.copyTo(netbuffer.cmds[j])
                        j++
                    }
                    // MAES: one of _D_ fixes.
                    //netbuffer.cmds[j] = localcmds[(realstart+j)%BACKUPTICS];
                    if (remoteresend[i]) {
                        netbuffer.retransmitfrom = nettics[i].toByte()
                        HSendPacket(i, NetConsts.NCMD_RETRANSMIT)
                    } else {
                        netbuffer.retransmitfrom = 0
                        HSendPacket(i, 0)
                    }
                }
                i++
            }
            GetPackets()
        }
    }

    //
    // CheckAbort
    //
    private fun CheckAbort() {
        var ev: event_t?
        val stoptic: Int
        stoptic = ticker.GetTime() + 2
        while (ticker.GetTime() < stoptic) {
        }
        //videoInterface.StartTic (); 

        //videoInterface.StartTic ();
        while (eventtail != eventhead) {
            ev = events[eventtail]
            if (ev!!.isKey(ScanCode.SC_ESCAPE, evtype_t.ev_keydown)) {
                doomSystem.Error("Network game synchronization aborted.")
            }
            eventtail = ++eventtail and Limits.MAXEVENTS - 1
        }
    }

    var gotinfo = BooleanArray(Limits.MAXNETNODES)

    /**
     * D_ArbitrateNetStart
     * @throws IOException
     */
    @Throws(IOException::class)
    fun ArbitrateNetStart() {
        var i: Int
        autostart = true

        // Clear it up...
        C2JUtils.memset(gotinfo, false, gotinfo.size)
        val doomcom = doomcom!!
        if (doomcom.consoleplayer.toInt() != 0) {
            // listen for setup info from key player
            println("listening for network start info...\n")
            while (true) {
                CheckAbort()
                if (!HGetPacket()) {
                    continue
                }
                val netbuffer = netbuffer!!
                if (C2JUtils.flags(netbuffer.checksum, NetConsts.NCMD_SETUP)) {
                    if (netbuffer.player.toInt() != Defines.VERSION) {
                        doomSystem.Error("Different DOOM versions cannot play a net game!")
                    }
                    startskill = skill_t.values()[netbuffer.retransmitfrom.toInt() and 15]
                    if (netbuffer.retransmitfrom.toInt() and 0xc0 shr 6 == 1) {
                        // Deathmatch
                        deathmatch = true
                    } else if (netbuffer.retransmitfrom.toInt() and 0xc0 shr 6 == 2) {
                        // Cooperative
                        altdeath = true
                    }
                    nomonsters = netbuffer.retransmitfrom.toInt() and 0x20 > 0
                    respawnparm = netbuffer.retransmitfrom.toInt() and 0x10 > 0
                    startmap = netbuffer.starttic.toInt() and 0x3f
                    startepisode = netbuffer.starttic.toInt() shr 6
                    return
                }
            }
        } else {
            // key player, send the setup info
            println("sending network start info...\n")
            do {
                CheckAbort()
                i = 0
                val netbuffer = netbuffer!!
                while (i < doomcom.numnodes) {
                    netbuffer.retransmitfrom = startskill!!.ordinal.toByte()
                    if (deathmatch) {
                        netbuffer.retransmitfrom = (netbuffer.retransmitfrom.toInt() or (1 shl 6)).toByte()
                    } else if (altdeath) {
                        netbuffer.retransmitfrom = (netbuffer.retransmitfrom.toInt() or (2 shl 6)).toByte()
                    }
                    if (nomonsters) {
                        netbuffer.retransmitfrom = (netbuffer.retransmitfrom.toInt() or 0x20).toByte()
                    }
                    if (respawnparm) {
                        netbuffer.retransmitfrom = (netbuffer.retransmitfrom.toInt() or 0x10).toByte()
                    }
                    netbuffer.starttic = (startepisode * 64 + startmap).toByte()
                    netbuffer.player = Defines.VERSION.toByte()
                    netbuffer.numtics = 0
                    HSendPacket(i, NetConsts.NCMD_SETUP)
                    i++
                }

                //#if 1
                i = 10
                while (i > 0 && HGetPacket()) {
                    if (netbuffer.player.toInt() and 0x7f < Limits.MAXNETNODES) {
                        gotinfo[netbuffer.player.toInt() and 0x7f] = true
                    }
                    --i
                }
                /*
                while (HGetPacket ())
                {
                gotinfo[netbuffer.player&0x7f] = true;
                }
                */i = 1
                while (i < doomcom.numnodes) {
                    if (!gotinfo[i]) {
                        break
                    }
                    i++
                }
            } while (i < doomcom.numnodes)
        }
    }

    /**
     * D_CheckNetGame
     * Works out player numbers among the net participants
     */
    @Throws(IOException::class)
    private fun CheckNetGame() {
        for (i in 0 until Limits.MAXNETNODES) {
            nodeingame[i] = false
            nettics[i] = 0
            remoteresend[i] = false // set when local needs tics
            resendto[i] = 0 // which tic to start sending
        }

        // I_InitNetwork sets doomcom and netgame
        systemNetworking.InitNetwork()
        val doomcom = doomcom!!
        if (doomcom.id != NetConsts.DOOMCOM_ID) {
            doomSystem.Error("Doomcom buffer invalid!")
        }

        // Maes: This is the only place where netbuffer is definitively set to something
        netbuffer = doomcom.data
        displayplayer = doomcom.consoleplayer.toInt()
        consoleplayer = displayplayer
        if (netgame) {
            ArbitrateNetStart()
        }
        System.out.printf(
            "startskill %s  deathmatch: %s  startmap: %d  startepisode: %d\n",
            startskill.toString(), java.lang.Boolean.toString(deathmatch), startmap, startepisode
        )

        // read values out of doomcom
        _ticdup = doomcom.ticdup.toInt()
        // MAES: ticdup must not be zero at this point. Obvious, no?
        maxsend = Defines.BACKUPTICS / (2 * _ticdup) - 1
        if (maxsend < 1) {
            maxsend = 1
        }
        for (i in 0 until doomcom.numplayers) {
            playeringame[i] = true
        }
        for (i in 0 until doomcom.numnodes) {
            nodeingame[i] = true
        }
        System.out.printf("player %d of %d (%d nodes)\n", consoleplayer + 1, doomcom.numplayers, doomcom.numnodes)
    }

    /**
     * D_QuitNetGame
     * Called before quitting to leave a net game
     * without hanging the other players
     */
    @Throws(IOException::class)
    override fun QuitNetGame() {
        if (C2JUtils.eval(debugfile)) {
            try {
                debugfile!!.close()
            } catch (e: IOException) {
                e.printStackTrace()
            }
        }
        if (!netgame || !usergame || consoleplayer == -1 || demoplayback) {
            return
        }

        // send a bunch of packets for security
        val netbuffer = netbuffer!!
        netbuffer.player = consoleplayer.toByte()
        netbuffer.numtics = 0
        val doomcom = doomcom!!
        for (i in 0..3) {
            for (j in 1 until doomcom.numnodes) {
                if (nodeingame[j]) {
                    HSendPacket(j, NetConsts.NCMD_EXIT)
                }
            }
            doomSystem.WaitVBL(1)
        }
    }

    /**
     * TryRunTics
     */
    var frametics = IntArray(4)
    var frameon = 0
    var frameskip = BooleanArray(4)
    var oldnettics = 0
    var oldentertics = 0
    @Throws(IOException::class)
    override fun TryRunTics() {
        var lowtic: Int
        val entertic: Int
        val realtics: Int
        val availabletics: Int
        var counts: Int
        var numplaying: Int

        // get real tics        
        entertic = ticker.GetTime() / _ticdup
        realtics = entertic - oldentertics
        oldentertics = entertic

        //System.out.printf("Entertic %d, realtics %d, oldentertics %d\n",entertic,realtics,oldentertics);
        // get available tics
        NetUpdate()
        lowtic = Limits.MAXINT
        numplaying = 0

        val doomcom = doomcom!!
        doomcom.numnodes.times { i ->
            if (nodeingame[i]) {
                numplaying++
                if (nettics[i] < lowtic) {
                    lowtic = nettics[i]
                }
            }
        }
        availabletics = lowtic - gametic / _ticdup

        // decide how many tics to run
        counts = if (realtics < availabletics - 1) {
            realtics + 1
        } else if (realtics < availabletics) {
            realtics
        } else {
            availabletics
        }
        if (counts < 1) {
            counts = 1
        }
        frameon++

        if (C2JUtils.eval(debugfile)) {
            sb.setLength(0)
            sb.append("=======real: ")
            sb.append(realtics)
            sb.append("  avail: ")
            sb.append(availabletics)
            sb.append("  game: ")
            sb.append(counts)
            sb.append("\n")
            debugfile!!.write(sb.toString())
        }
        if (!demoplayback) {
            // ideally nettics[0] should be 1 - 3 tics above lowtic
            // if we are consistantly slower, speed up time
            var i = 0
            while (i < Limits.MAXPLAYERS) {
                if (playeringame[i]) {
                    break
                }
                i++
            }
            if (consoleplayer == i) {
                // the key player does not adapt
            } else {
                if (nettics[0] <= nettics[nodeforplayer[i]]) {
                    gametime--
                    print("-")
                }
                frameskip[frameon and 3] = oldnettics > nettics[nodeforplayer[i]]
                oldnettics = nettics[0]
                if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3]) {
                    skiptics = 1
                    print("+")
                }
            }
        } // demoplayback

        // wait for new tics if needed
        while (lowtic < gametic / _ticdup + counts) {
            NetUpdate()
            lowtic = Limits.MAXINT

            // Finds the node with the lowest number of tics.

            doomcom.numnodes.times { i ->
                if (nodeingame[i] && nettics[i] < lowtic) {
                    lowtic = nettics[i]
                }
            }
            if (lowtic < gametic / _ticdup) {
                doomSystem.Error("TryRunTics: lowtic < gametic")
            }

            // don't stay in here forever -- give the menu a chance to work
            val time = ticker.GetTime()
            if (time / _ticdup - entertic >= 20) {
                menu.Ticker()
                return
            }
        }

        // run the count * ticdup dics
        while (counts-- > 0) {

            _ticdup.times { i ->
                if (gametic / _ticdup > lowtic) {
                    doomSystem.Error("gametic>lowtic")
                }
                if (advancedemo) {
                    DoAdvanceDemo()
                }
                menu.Ticker()
                Ticker()
                gametic++

                // modify command for duplicated tics
                if (i != _ticdup - 1) {
                    var cmd: ticcmd_t
                    val buf = gametic / _ticdup % Defines.BACKUPTICS

                    netcmds.forEach{ netcmd ->
                        cmd = netcmd[buf]!!
                        cmd.chatchar = 0.toChar()
                        if (C2JUtils.flags(cmd.buttons.code, Defines.BT_SPECIAL)) {
                            cmd.buttons = 0.toChar()
                        }
                    }
                }
            }
            NetUpdate() // check for new console commands
        }
    }

    override fun getDoomCom(): doomcom_t? {
        return doomcom
    }

    override fun setDoomCom(doomcom: doomcom_t?) {
        this.doomcom = doomcom
    }

    override fun setGameAction(action: gameaction_t) {
        gameaction = action
    }

    override fun getGameAction(): gameaction_t {
        return gameaction
    }

    val vs: VideoScale

    /**
     * Since this is a fully OO implementation, we need a way to create
     * the instances of the Refresh daemon, the Playloop, the Wadloader
     * etc. which however are now completely independent of each other
     * (well, ALMOST), and are typically only passed context when
     * instantiated.
     *
     * If you instantiate one too early, it will have null context.
     *
     * The trick is to construct objects in the correct order. Some of
     * them have Init() methods which are NOT yet safe to call.
     *
     */
    init {
        // Init game status...

        // Init players
        players = arrayOfNulls<player_t>(Limits.MAXPLAYERS) as Array<player_t>
        Arrays.setAll(players) { i: Int -> player_t(this) }

        // Init objects
        cVarManager = Engine.getCVM()

        // Prepare events array with event instances
        Arrays.fill(events, event_t.EMPTY_EVENT)

        // Create DoomSystem
        doomSystem = DoomSystem(this)

        // Choose bppMode depending on CVar's
        // TODO: add config options
        bppMode = BppMode.chooseBppMode(cVarManager)

        // Create real time ticker
        RealTime = MilliTicker()

        // Doommain is both "main" and handles most of the game status.
        gameNetworking = this // DoomMain also handles its own Game Networking.

        // Set ticker. It is a shared status object, but not a holder itself.
        ticker = ITicker.createTicker(cVarManager)

        // Network "driver"
        systemNetworking = DummyNetworkDriver<T, V>(this)

        // Random number generator, but we can have others too.
        random = DelegateRandom()
        print(String.format("M_Random: Using %s.\n", random.javaClass.simpleName))

        // Sound can be left until later, in Start
        wadLoader = WadLoader(doomSystem) // The wadloader is a "weak" status holder.

        // TODO: find out if we have requests for a specific resolution,
        // and try honouring them as closely as possible.       

        // 23/5/2011: Experimental dynamic resolution subsystem
        vs = VisualSettings.parse(cVarManager)
        spriteManager = SpriteManager<T, V>(this)

        // Heads-up, Menu, Level Loader
        headsUp = HU(this)
        menu = Menu<T, V>(this)
        levelLoader = BoomLevelLoader(this)

        // Renderer, Actions, StatusBar, AutoMap
        sceneRenderer = bppMode.sceneRenderer(this)
        actions = ActionFunctions(this)
        statusBar = StatusBar(this)

        // Let the renderer pick its own. It makes linking easier.
        textureManager = sceneRenderer.getTextureManager()
        // Instantiating EndLevel, Finale
        endLevel = EndLevel(this)
        finale = selectFinale()
        readCVars()
        print("W_Init: Init WADfiles.\n")
        try {
            wadLoader.InitMultipleFiles(wadfiles)
        } catch (e1: Exception) {
            // TODO Auto-generated catch block
            e1.printStackTrace()
        }

        // Video Renderer
        graphicSystem = RendererFactory.newBuilder<T, V>()
            .setVideoScale(vs).setBppMode(bppMode).setWadLoader(wadLoader)
            .build()
        print("V_Init: allocate screens.\n")

        // Disk access visualizer
        diskDrawer = DiskDrawer(this, DiskDrawer.STDISK)

        // init subsystems
        print("AM_Init: Init Automap colors - \n")
        autoMap = automap.Map(this)
        wiper = graphicSystem.createWiper(random)

        // Update variables and stuff NOW.
        update()

        // Check for -file in shareware
        CheckForPWADSInShareware()
        printGameInfo()
        print("Tables.InitTables: Init trigonometric LUTs.\n")
        Tables.InitTables()
        print("M_Init: Init miscellaneous info.\n")
        menu.Init()
        print("R_Init: Init DOOM refresh daemon - ")
        sceneRenderer.Init()
        print("\nP_Init: Init Playloop state.\n")
        actions.Init()
        print("I_Init: Setting up machine state.\n")
        doomSystem.Init()
        print("D_CheckNetGame: Checking network game status.\n")
        CheckNetGame()
        print("S_Init: Setting up sound.\n")

        // Sound "drivers" before the game sound controller.
        music = IMusic.chooseModule(cVarManager)
        soundDriver = ISoundDriver.chooseModule(this, cVarManager)
        doomSound = IDoomSound.chooseSoundIsPresent(this, cVarManager, soundDriver)
        music.InitMusic()
        doomSound.Init(snd_SfxVolume * 8, snd_MusicVolume * 8)
        print("HU_Init: Setting up heads up display.\n")
        headsUp.Init()
        print("ST_Init: Init status bar.\n")
        statusBar.Init()
        if (statcopy != null) {
            print("External statistics registered.\n")
        }

        // NOW it's safe to init the disk reader.
        diskDrawer.Init()
    }

    fun shouldPollLockingKeys(): Boolean {
        if (keysCleared) {
            keysCleared = false
            return true
        }
        return false
    }

    private fun findFileNameToSave(): String? {
        val format = "DOOM%d%d%d%d.png"
        var lbmname: String? = null
        // find a file name to save it to
        val digit = IntArray(4)
        var i: Int
        i = 0
        while (i <= 9999) {
            digit[0] = i / 1000 % 10
            digit[1] = i / 100 % 10
            digit[2] = i / 10 % 10
            digit[3] = i % 10
            lbmname = String.format(format, digit[0], digit[1], digit[2], digit[3])
            if (!C2JUtils.testReadAccess(lbmname)) {
                break // file doesn't exist
            }
            i++
        }
        if (i == 10000) {
            doomSystem.Error("M_ScreenShot: Couldn't create a PNG")
        }
        return lbmname
    }

    override fun selectFinale(): Finale<T> {
        return Finale(this)
    }

    /**
     * M_Screenshot
     *
     * Currently saves PCX screenshots, and only in devparm.
     * Very oldschool ;-)
     *
     * TODO: add non-devparm hotkey for screenshots, sequential screenshot
     * messages, option to save as either PCX or PNG. Also, request
     * current palette from VI (otherwise gamma settings and palette effects
     * don't show up).
     *
     */
    override fun ScreenShot() {
        // find a file name to save it to
        val lbmname = findFileNameToSave() // file doesn't exist
        if (graphicSystem.writeScreenShot(lbmname, DoomScreen.FG)) {
            players[consoleplayer].message = englsh.SCREENSHOT
        }
    }

    companion object {
        const val RCSID = "\$Id: DoomMain.java,v 1.109 2012/11/06 16:04:58 velktron Exp $"
    }
}